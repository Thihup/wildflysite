<!DOCTYPE html>
<html lang="en"><head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1"><!-- Begin Jekyll SEO tag v2.5.0 -->
<title>Detyped management and the jboss-dmr library | Wildfly</title>
<meta name="generator" content="Jekyll v3.8.3" />
<meta property="og:title" content="Detyped management and the jboss-dmr library" />
<meta property="og:locale" content="en_US" />
<link rel="canonical" href="https://jbossorg.github.io/wildflysite/docs/13/_admin-guide/management-api/Detyped_management_and_the_jboss-dmr_library.html" />
<meta property="og:url" content="https://jbossorg.github.io/wildflysite/docs/13/_admin-guide/management-api/Detyped_management_and_the_jboss-dmr_library.html" />
<meta property="og:site_name" content="Wildfly" />
<script type="application/ld+json">
{"@type":"WebPage","url":"https://jbossorg.github.io/wildflysite/docs/13/_admin-guide/management-api/Detyped_management_and_the_jboss-dmr_library.html","headline":"Detyped management and the jboss-dmr library","@context":"http://schema.org"}</script>
<!-- End Jekyll SEO tag -->
<link rel="stylesheet" href="/wildflysite/assets/main.css"><link type="application/atom+xml" rel="alternate" href="https://jbossorg.github.io/wildflysite/feed.xml" title="Wildfly" /></head>
<body><div class="header navigation">
  <div class="logo-wrapper">
    <a href="/wildflysite/"><img class="wf-logo" src="/wildflysite/assets/img/wildfly_icons_one-color-logo.png"></a>
  </div>
  <div class="nav-container">
    <nav>
      <div class="nav-mobile"><a id="nav-toggle" href="#!"><span></span></a></div>
      <ul class="nav-list">
        <li>
          <a href="/wildflysite/" class="">Home</a>
        </li>
        <li>
          <a href="/wildflysite/downloads/" class="">Downloads</a>
        </li>
        <li>
          <a href="/wildflysite/blog/" class="">Blog</a>
        </li>
        <li>
          <a href="/wildflysite/about/" class="">About</a>
        </li>
        <li>
          <a href="/wildflysite/contribute/" class="">Contribute</a>
        </li>
        <li>
          <a href="/wildflysite/docs/" class="">Docs</a>
        </li>
        <li>
          <a class="button-cta secondary" href="https://github.com/wildfly/wildfly/fork" target="_blank">Fork</a>
        </li>
      </ul>
    </nav>
  </div>
</div>
<main class="page-content" aria-label="Content">
      <div class="wrapper">
        <div id="preamble">
<div class="sectionbody">
<div class="paragraph">
<p>The management model exposed by WildFly is very large and complex. There
are dozens, probably hundreds of logical concepts involved – hosts,
server groups, servers, subsystems, datasources, web connectors, and on
and on – each of which in a classic objected oriented API design could
be represented by a Java <em>type</em> (i.e. a Java class or interface.)
However, a primary goal in the development of WildFly&#8217;s native
management API was to ensure that clients built to use the API had as
few compile-time and run-time dependencies on JBoss-provided classes as
possible, and that the API exposed by those libraries be powerful but
also simple and stable. A management client running with the management
libraries created for an earlier version of WildFly should still work if
used to manage a later version domain. The management client libraries
needed to be <em>forward compatible</em>.</p>
</div>
<div class="paragraph">
<p>It is highly unlikely that an API that consists of hundreds of Java
types could be kept forward compatible. Instead, the WildFly management
API is a <em>detyped</em> API. A detyped API is like decaffeinated coffee – it
still has a little bit of caffeine, but not enough to keep you awake at
night. WildFly&#8217;s management API still has a few Java types in it (it&#8217;s
impossible for a Java library to have no types!) but not enough to keep
you (or us) up at night worrying that your management clients won&#8217;t be
forward compatible.</p>
</div>
<div class="paragraph">
<p>A detyped API works by making it possible to build up arbitrarily
complex data structures using a small number of Java types. All of the
parameter values and return values in the API are expressed using those
few types. Ideally, most of the types are basic JDK types, like
<code>java.lang.String</code>, <code>java.lang.Integer</code>, etc. In addition to the basic
JDK types, WildFly&#8217;s detyped management API uses a small library called
<strong>jboss-dmr</strong>. The purpose of this section is to provide a basic overview
of the jboss-dmr library.</p>
</div>
<div class="paragraph">
<p>Even if you don&#8217;t use jboss-dmr directly (probably the case for all but
a few users), some of the information in this section may be useful.
When you invoke operations using the application server&#8217;s Command Line
Interface, the return values are just the text representation of of a
jboss-dmr <code>ModelNode</code>. If your CLI commands require complex parameter
values, you may yourself end up writing the text representation of a
<code>ModelNode</code>. And if you use the HTTP management API, all response bodies
as well as the request body for any POST will be a JSON representation
of a <code>ModelNode</code>.</p>
</div>
<div class="paragraph">
<p>The source code for jboss-dmr is available on
<a href="https://github.com/jbossas/jboss-dmr">Github</a>. The maven coordinates for
a jboss-dmr release are <code>org.jboss.jboss-dmr:jboss-dmr</code>.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="modelnode-and-modeltype">ModelNode and ModelType</h2>
<div class="sectionbody">
<div class="paragraph">
<p>The public API exposed by jboss-dmr is very simple: just three classes,
one of which is an enum!</p>
</div>
<div class="paragraph">
<p>The primary class is <code>org.jboss.dmr.ModelNode</code>. A <code>ModelNode</code> is
essentially just a wrapper around some <em>value</em>; the value is typically
some basic JDK type. A <code>ModelNode</code> exposes a <code>getType()</code> method. This
method returns a value of type <code>org.jboss.dmr.ModelType</code>, which is an
enum of all the valid types of values. And that&#8217;s 95% of the public API;
a class and an enum. (We&#8217;ll get to the third class, <code>Property</code>, below.)</p>
</div>
<div class="sect2">
<h3 id="basic-modelnode-manipulation">Basic ModelNode manipulation</h3>
<div class="paragraph">
<p>To illustrate how to work with <code>ModelNode</code> s, we&#8217;ll use the
<a href="http://www.beanshell.org">Beanshell</a> scripting library. We won&#8217;t get into
many details of beanshell here; it&#8217;s a simple and intuitive tool and
hopefully the following examples are as well.</p>
</div>
<div class="paragraph">
<p>We&#8217;ll start by launching a beanshell interpreter, with the jboss-dmr
library available on the classpath. Then we&#8217;ll tell beanshell to import
all the jboss-dmr classes so they are available for use:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">$ java -cp bsh-2.0b4.jar:jboss-dmr-1.0.0.Final.jar bsh.Interpreter
BeanShell 2.0b4 - by Pat Niemeyer (pat@pat.net)
bsh % import org.jboss.dmr.*;
bsh %</code></pre>
</div>
</div>
<div class="paragraph">
<p>Next, create a <code>ModelNode</code> and use the beanshell <code>print</code> function to
output what type it is:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">bsh % ModelNode node = new ModelNode();
bsh % print(node.getType());
UNDEFINED</code></pre>
</div>
</div>
<div class="paragraph">
<p>A new <code>ModelNode</code> has no value stored, so its type is
<code>ModelType.UNDEFINED</code>.</p>
</div>
<div class="paragraph">
<p>Use one of the overloaded <code>set</code> method variants to assign a node&#8217;s
value:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">bsh % node.set(1);
bsh % print(node.getType());
INT
bsh % node.set(true);
bsh % print(node.getType());
BOOLEAN
bsh % node.set("Hello, world");
bsh % print(node.getType());
STRING</code></pre>
</div>
</div>
<div class="paragraph">
<p>Use one of the <code>asXXX()</code> methods to retrieve the value:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">bsh % node.set(2);
bsh % print(node.asInt());
2
bsh % node.set("A string");
bsh % print(node.asString());
A string</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>ModelNode</code> will attempt to perform type conversions when you invoke the
<code>asXXX</code> methods:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">bsh % node.set(1);
bsh % print(node.asString());
1
bsh % print(node.asBoolean());
true
bsh % node.set(0);
bsh % print(node.asBoolean());
false
bsh % node.set("true");
bsh % print(node.asBoolean());
true</code></pre>
</div>
</div>
<div class="paragraph">
<p>Not all type conversions are possible:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">bsh % node.set("A string");
bsh % print(node.asInt());
// Error: // Uncaught Exception: Method Invocation node.asInt : at Line: 20 : in file: &lt;unknown file&gt; : node .asInt ( )
 
Target exception: java.lang.NumberFormatException: For input string: "A string"
 
java.lang.NumberFormatException: For input string: "A string"
 at java.lang.NumberFormatException.forInputString(NumberFormatException.java:48)
 at java.lang.Integer.parseInt(Integer.java:449)
 at java.lang.Integer.parseInt(Integer.java:499)
 at org.jboss.dmr.StringModelValue.asInt(StringModelValue.java:61)
 at org.jboss.dmr.ModelNode.asInt(ModelNode.java:117)
        ....</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>ModelNode.getType()</code> method can be used to ensure a node has an
expected value type before attempting a type conversion.</p>
</div>
<div class="paragraph">
<p>One <code>set</code> variant takes another <code>ModelNode</code> as its argument. The value
of the passed in node is copied, so there is no shared state between the
two model nodes:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">bsh % node.set("A string");
bsh % ModelNode another = new ModelNode();
bsh % another.set(node);
bsh % print(another.asString());
A string
bsh % node.set("changed");
bsh % print(node.asString());
changed
bsh % print(another.asString());
A string</code></pre>
</div>
</div>
<div class="paragraph">
<p>A <code>ModelNode</code> can be cloned. Again, there is no shared state between the
original node and its clone:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">bsh % ModelNode clone = another.clone();
bsh % print(clone.asString());
A string
bsh % another.set(42);
bsh % print(another.asString());
42
bsh % print(clone.asString());
A string</code></pre>
</div>
</div>
<div class="paragraph">
<p>Use the <code>protect()</code> method to make a <code>ModelNode</code> immutable:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">bsh % clone.protect();
bsh % clone.set("A different string");
// Error: // Uncaught Exception: Method Invocation clone.set : at Line: 15 : in file: &lt;unknown file&gt; : clone .set ( "A different string" )
 
Target exception: java.lang.UnsupportedOperationException
 
java.lang.UnsupportedOperationException
 at org.jboss.dmr.ModelNode.checkProtect(ModelNode.java:1441)
 at org.jboss.dmr.ModelNode.set(ModelNode.java:351)
        ....</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="lists">Lists</h3>
<div class="paragraph">
<p>The above examples aren&#8217;t particularly interesting; if all we can do
with a <code>ModelNode</code> is wrap a simple Java primitive, what use is that?
However, a <code>ModelNode&#8217;s value can be more complex than a simple
primitive, and using these more complex types we can build complex data
structures. The first more complex type is `ModelType.LIST</code>.</p>
</div>
<div class="paragraph">
<p>Use the <code>add</code> methods to initialize a node&#8217;s value as a list and add to
the list:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">bsh % ModelNode list = new ModelNode();
bsh % list.add(5);
bsh % list.add(10);
bsh % print(list.getType());
LIST</code></pre>
</div>
</div>
<div class="paragraph">
<p>Use <code>asInt()</code> to find the size of the list:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">bsh % print(list.asInt());
2</code></pre>
</div>
</div>
<div class="paragraph">
<p>Use the overloaded <code>get</code> method variant that takes an int param to
retrieve an item. The item is returned as a <code>ModelNode</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">bsh % ModelNode child = list.get(1);
bsh % print(child.asInt());
10</code></pre>
</div>
</div>
<div class="paragraph">
<p>Elements in a list need not all be of the same type:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">bsh % list.add("A string");
bsh % print(list.get(1).getType());
INT
bsh % print(list.get(2).getType());
STRING</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Here&#8217;s one of the trickiest things about jboss-dmr:</strong> <em>The</em> <code>get</code>
<em>methods actually mutate state; they are not "read-only"</em>. For example,
calling <code>get</code> with an index that does not exist yet in the list will
actually create a child of type <code>ModelType.UNDEFINED</code> at that index (and
will create UNDEFINED children for any intervening indices.)</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">bsh % ModelNode four = list.get(4);
bsh % print(four.getType());
UNDEFINED
bsh % print(list.asInt());
6</code></pre>
</div>
</div>
<div class="paragraph">
<p>Since the <code>get</code> call always returns a <code>ModelNode</code> and never <code>null</code> it is
safe to manipulate the return value:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">bsh % list.get(5).set(30);
bsh % print(list.get(5).asInt());
30</code></pre>
</div>
</div>
<div class="paragraph">
<p>That&#8217;s not so interesting in the above example, but later on with node
of type <code>ModelType.OBJECT</code> we&#8217;ll see how that kind of method chaining
can let you build up fairly complex data structures with a minimum of
code.</p>
</div>
<div class="paragraph">
<p>Use the <code>asList()</code> method to get a <code>List&lt;ModelNode&gt;</code> of the children:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">bsh % for (ModelNode element : list.asList()) {
print(element.getType());
}
INT
INT
STRING
UNDEFINED
UNDEFINED
INT</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>asString()</code> and <code>toString()</code> methods provide slightly differently
formatted text representations of a <code>ModelType.LIST</code> node:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">bsh % print(list.asString());
[5,10,"A string",undefined,undefined,30]
bsh % print(list.toString());
[
    5,
    10,
    "A string",
    undefined,
    undefined,
    30
]</code></pre>
</div>
</div>
<div class="paragraph">
<p>Finally, if you&#8217;ve previously used <code>set</code> to assign a node&#8217;s value to
some non-list type, you cannot use the <code>add</code> method:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">bsh % node.add(5);
// Error: // Uncaught Exception: Method Invocation node.add : at Line: 18 : in file: &lt;unknown file&gt; : node .add ( 5 )
 
Target exception: java.lang.IllegalArgumentException
 
java.lang.IllegalArgumentException
 at org.jboss.dmr.ModelValue.addChild(ModelValue.java:120)
 at org.jboss.dmr.ModelNode.add(ModelNode.java:1007)
 at org.jboss.dmr.ModelNode.add(ModelNode.java:761)
        ...</code></pre>
</div>
</div>
<div class="paragraph">
<p>You can, however, use the <code>setEmptyList()</code> method to change the node&#8217;s
type, and then use <code>add</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">bsh % node.setEmptyList();
bsh % node.add(5);
bsh % print(node.toString());
[5]</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="dmr-properties">Properties</h3>
<div class="paragraph">
<p>The third public class in the jboss-dmr library is
<code>org.jboss.dmr.Property</code>. A <code>Property</code> is a <code>String &#8658; ModelNode</code> tuple.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">bsh % Property prop = new Property("stuff", list);
bsh % print(prop.toString());
org.jboss.dmr.Property@79a5f739
bsh % print(prop.getName());
stuff
bsh % print(prop.getValue());
[
    5,
    10,
    "A string",
    undefined,
    undefined,
    30
]</code></pre>
</div>
</div>
<div class="paragraph">
<p>The property can be passed to <code>ModelNode.set</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">bsh % node.set(prop);
bsh % print(node.getType());
PROPERTY</code></pre>
</div>
</div>
<div class="paragraph">
<p>The text format for a node of <code>ModelType.PROPERTY</code> is:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">bsh % print(node.toString());
("stuff" =&gt; [
    5,
    10,
    "A string",
    undefined,
    undefined,
    30
])</code></pre>
</div>
</div>
<div class="paragraph">
<p>Directly instantiating a <code>Property</code> via its constructor is not common.
More typically one of the two argument <code>ModelNode.add</code> or
<code>ModelNode.set</code> variants is used. The first argument is the property
name:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">bsh % ModelNode simpleProp = new ModelNode();
bsh % simpleProp.set("enabled", true);
bsh % print(simpleProp.toString());
("enabled" =&gt; true)
bsh % print(simpleProp.getType());
PROPERTY
bsh % ModelNode propList = new ModelNode();
bsh % propList.add("min", 1);
bsh % propList.add("max", 10);
bsh % print(propList.toString());
[
    ("min" =&gt; 1),
    ("max" =&gt; 10)
]
bsh % print(propList.getType());
LIST
bsh % print(propList.get(0).getType());
PROPERTY</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>asPropertyList()</code> method provides easy access to a
<code>List&lt;Property&gt;</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">bsh % for (Property prop : propList.asPropertyList()) {
print(prop.getName() + " = " + prop.getValue());
}
min = 1
max = 10</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="modeltype.object">ModelType.OBJECT</h3>
<div class="paragraph">
<p>The most powerful and most commonly used complex value type in jboss-dmr
is <code>ModelType.OBJECT</code>. A <code>ModelNode</code> whose value is <code>ModelType.OBJECT</code>
internally maintains a <code>Map&lt;String, ModelNode</code>.</p>
</div>
<div class="paragraph">
<p>Use the <code>get</code> method variant that takes a string argument to add an
entry to the map. If no entry exists under the given name, a new entry
is added with a the value being a <code>ModelType.UNDEFINED</code> node. The node
is returned:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">bsh % ModelNode range = new ModelNode();
bsh % ModelNode min = range.get("min");
bsh % print(range.toString());
{"min" =&gt; undefined}
bsh % min.set(2);
bsh % print(range.toString());
{"min" =&gt; 2}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Again <strong>it is important to remember that the</strong> <code>get</code> <strong>operation may mutate
the state of a model node by adding a new entry.</strong> <em>It is not a read-only
operation.</em></p>
</div>
<div class="paragraph">
<p>Since <code>get</code> will never return <code>null</code>, a common pattern is to use method
chaining to create the key/value pair:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">bsh % range.get("max").set(10);
bsh % print(range.toString());
{
    "min" =&gt; 2,
    "max" =&gt; 10
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>A call to <code>get</code> passing an already existing key will of course return
the same model node as was returned the first time <code>get</code> was called with
that key:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">bsh % print(min == range.get("min"));
true</code></pre>
</div>
</div>
<div class="paragraph">
<p>Multiple parameters can be passed to <code>get</code>. This is a simple way to
traverse a tree made up of <code>ModelType.OBJECT</code> nodes. Again, <code>get</code> may
mutate the node on which it is invoked; e.g. it will actually create the
tree if nodes do not exist. This next example uses a workaround to get
beanshell to handle the overloaded <code>get</code> method that takes a variable
number of arguments:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">bsh % String[] varargs = { "US", "Missouri", "St. Louis" };
bsh % salesTerritories.get(varargs).set("Brian");
bsh % print(salesTerritories.toString());
{"US" =&gt; {"Missouri" =&gt; {"St. Louis" =&gt; "Brian"}}}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The normal syntax would be:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>salesTerritories.get("US", "Missouri", "St. Louis").set("Brian");</pre>
</div>
</div>
<div class="paragraph">
<p>The key/value pairs in the map can be accessed as a <code>List&lt;Property</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">bsh % for (Property prop : range.asPropertyList()) {
print(prop.getName() + " = " + prop.getValue());
}
min = 2</code></pre>
</div>
</div>
<div class="paragraph">
<p>The semantics of the backing map in a node of <code>ModelType.OBJECT</code> are
those of a <code>LinkedHashMap</code>. The map remembers the order in which
key/value pairs are added. This is relevant when iterating over the
pairs after calling <code>asPropertyList()</code> and for controlling the order in
which key/value pairs appear in the output from <code>toString()</code>.</p>
</div>
<div class="paragraph">
<p>Since the <code>get</code> method will actually mutate the state of a node if the
given key does not exist, <code>ModelNode</code> provides a couple methods to let
you check whether the entry is there. The <code>has</code> method simply does that:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">bsh % print(range.has("unit"));
false
bsh % print(range.has("min"));
true</code></pre>
</div>
</div>
<div class="paragraph">
<p>Very often, the need is to not only know whether the key/value pair
exists, but whether the value is defined (i.e. not
<code>ModelType.UNDEFINED</code>. This kind of check is analogous to checking
whether a field in a Java class has a null value. The <code>hasDefined</code> lets
you do this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">bsh % print(range.hasDefined("unit"));
false
bsh % // Establish an undefined child 'unit';
bsh % range.get("unit");
bsh % print(range.toString());
{
    "min" =&gt; 2,
    "max" =&gt; 10,
    "unit" =&gt; undefined
}
bsh % print(range.hasDefined("unit"));
false
bsh % range.get("unit").set("meters");
bsh % print(range.hasDefined("unit"));
true</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="modeltype.expression">ModelType.EXPRESSION</h3>
<div class="paragraph">
<p>A value of type <code>ModelType.EXPRESSION</code> is stored as a string, but can
later be <em>resolved</em> to different value. The string has a special syntax
that should be familiar to those who have used the system property
substitution feature in previous JBoss AS releases.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">[&lt;prefix&gt;][${&lt;system-property-name&gt;[:&lt;default-value&gt;]}][&lt;suffix&gt;]*</code></pre>
</div>
</div>
<div class="paragraph">
<p>For example:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>${queue.length}
http://${host}
http://${host:localhost}:${port:8080}/index.html</pre>
</div>
</div>
<div class="paragraph">
<p>Use the <code>setExpression</code> method to set a node&#8217;s value to type expression:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">bsh % ModelNode expression = new ModelNode();
bsh % expression.setExpression("${queue.length}");
bsh % print(expression.getType());
EXPRESSION</code></pre>
</div>
</div>
<div class="paragraph">
<p>Calling <code>asString()</code> returns the same string that was input:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">bsh % print(expression.asString());
${queue.length}</code></pre>
</div>
</div>
<div class="paragraph">
<p>However, calling <code>toString()</code> tells you that this node&#8217;s value is not of
<code>ModelType.STRING</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">bsh % print(expression.toString());
expression "${queue.length}"</code></pre>
</div>
</div>
<div class="paragraph">
<p>When the <code>resolve</code> operation is called, the string is parsed and any
embedded system properties are resolved against the JVM&#8217;s current system
property values. A new <code>ModelNode</code> is returned whose value is the
resolved string:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">bsh % System.setProperty("queue.length", "10");
bsh % ModelNode resolved = expression.resolve();
bsh % print(resolved.asInt());
10</code></pre>
</div>
</div>
<div class="paragraph">
<p>Note that the type of the <code>ModelNode</code> returned by <code>resolve()</code> is
<code>ModelType.STRING</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">bsh % print(resolved.getType());
STRING</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>resolved.asInt()</code> call in the previous example only worked because
the string "10" happens to be convertible into the int 10.</p>
</div>
<div class="paragraph">
<p>Calling <code>resolve()</code> has no effect on the value of the node on which the
method is invoked:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">bsh % resolved = expression.resolve();
bsh % print(resolved.toString());
"10"
bsh % print(expression.toString());
expression "${queue.length}"</code></pre>
</div>
</div>
<div class="paragraph">
<p>If an expression cannot be resolved, <code>resolve</code> just uses the original
string. The string can include more than one system property
substitution:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">bsh % expression.setExpression("http://${host}:${port}/index.html");
bsh % resolved = expression.resolve();
bsh % print(resolved.asString());
http://${host}:${port}/index.html</code></pre>
</div>
</div>
<div class="paragraph">
<p>The expression can optionally include a default value, separated from
the name of the system property by a colon:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">bsh % expression.setExpression("http://${host:localhost}:${port:8080}/index.html");
bsh % resolved = expression.resolve();
bsh % print(resolved.asString());
http://localhost:8080/index.html</code></pre>
</div>
</div>
<div class="paragraph">
<p>Actually including a system property substitution in the expression is
not required:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">bsh % expression.setExpression("no system property");
bsh % resolved = expression.resolve();
bsh % print(resolved.asString());
no system property
bsh % print(expression.toString());
expression "no system property"</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>resolve</code> method works on nodes of other types as well; it returns a
copy without attempting any real resolution:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">bsh % ModelNode basic = new ModelNode();
bsh % basic.set(10);
bsh % resolved = basic.resolve();
bsh % print(resolved.getType());
INT
bsh % resolved.set(5);
bsh % print(resolved.asInt());
5
bsh % print(basic.asInt());
10</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="modeltype.type">ModelType.TYPE</h3>
<div class="paragraph">
<p>You can also pass one of the values of the <code>ModelType</code> enum to <code>set</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">bsh % ModelNode type = new ModelNode();
bsh % type.set(ModelType.LIST);
bsh % print(type.getType());
TYPE
bsh % print(type.toString());
LIST</code></pre>
</div>
</div>
<div class="paragraph">
<p>This is useful when using a <code>ModelNode</code> data structure to describe
another <code>ModelNode</code> data structure.</p>
</div>
</div>
<div class="sect2">
<h3 id="full-list-of-modelnode-types">Full list of ModelNode types</h3>
<div class="paragraph">
<p>BIG_DECIMAL<br>
BIG_INTEGER<br>
BOOLEAN<br>
BYTES<br>
DOUBLE<br>
EXPRESSION<br>
INT<br>
LIST<br>
LONG<br>
OBJECT<br>
PROPERTY<br>
STRING<br>
TYPE<br>
UNDEFINED</p>
</div>
</div>
<div class="sect2">
<h3 id="text-representation-of-a-modelnode">Text representation of a ModelNode</h3>
<div class="paragraph">
<p>TODO – document the grammar</p>
</div>
</div>
<div class="sect2">
<h3 id="json-representation-of-a-modelnode">JSON representation of a ModelNode</h3>
<div class="paragraph">
<p>TODO – document the grammar</p>
</div>
</div>
</div>
</div>
      </div>
    </main><footer class="site-footer h-card">
  <data class="u-url" href="/wildflysite/"></data>

  <div class="wrapper">

    <h2 class="footer-heading">Wildfly</h2>

    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <li class="p-name">Wildfly</li></ul>
      </div>

      <div class="footer-col footer-col-2"><ul class="social-media-list"><li><a href="https://github.com/wildfly"><svg class="svg-icon"><use xlink:href="/wildflysite/assets/minima-social-icons.svg#github"></use></svg> <span class="username">wildfly</span></a></li><li><a href="https://www.twitter.com/WildFlyAS"><svg class="svg-icon"><use xlink:href="/wildflysite/assets/minima-social-icons.svg#twitter"></use></svg> <span class="username">WildFlyAS</span></a></li></ul>
</div>

      <div class="footer-col footer-col-3">
        <p></p>
      </div>
    </div>

  </div>

</footer>
</body>

</html>
