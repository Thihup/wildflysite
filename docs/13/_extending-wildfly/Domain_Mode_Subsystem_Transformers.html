<!DOCTYPE html>
<html lang="en"><head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1"><!-- Begin Jekyll SEO tag v2.5.0 -->
<title>Domain Mode Subsystem Transformers | Wildfly</title>
<meta name="generator" content="Jekyll v3.8.3" />
<meta property="og:title" content="Domain Mode Subsystem Transformers" />
<meta property="og:locale" content="en_US" />
<link rel="canonical" href="https://jbossorg.github.io/wildflysite/docs/13/_extending-wildfly/Domain_Mode_Subsystem_Transformers.html" />
<meta property="og:url" content="https://jbossorg.github.io/wildflysite/docs/13/_extending-wildfly/Domain_Mode_Subsystem_Transformers.html" />
<meta property="og:site_name" content="Wildfly" />
<script type="application/ld+json">
{"@type":"WebPage","url":"https://jbossorg.github.io/wildflysite/docs/13/_extending-wildfly/Domain_Mode_Subsystem_Transformers.html","headline":"Domain Mode Subsystem Transformers","@context":"http://schema.org"}</script>
<!-- End Jekyll SEO tag -->
<link rel="stylesheet" href="/wildflysite/assets/main.css"><link type="application/atom+xml" rel="alternate" href="https://jbossorg.github.io/wildflysite/feed.xml" title="Wildfly" /></head>
<body><div class="header navigation">
  <div class="logo-wrapper">
    <a href="/wildflysite/"><img class="wf-logo" src="/wildflysite/assets/img/wildfly_icons_one-color-logo.png"></a>
  </div>
  <div class="nav-container">
    <nav>
      <div class="nav-mobile"><a id="nav-toggle" href="#!"><span></span></a></div>
      <ul class="nav-list">
        <li>
          <a href="/wildflysite/" class="">Home</a>
        </li>
        <li>
          <a href="/wildflysite/downloads/" class="">Downloads</a>
        </li>
        <li>
          <a href="/wildflysite/blog/" class="">Blog</a>
        </li>
        <li>
          <a href="/wildflysite/about/" class="">About</a>
        </li>
        <li>
          <a href="/wildflysite/contribute/" class="">Contribute</a>
        </li>
        <li>
          <a href="/wildflysite/docs/" class="">Docs</a>
        </li>
        <li>
          <a class="button-cta secondary" href="https://github.com/wildfly/wildfly/fork" target="_blank">Fork</a>
        </li>
      </ul>
    </nav>
  </div>
</div>
<main class="page-content" aria-label="Content">
      <div class="wrapper">
        <div id="preamble">
<div class="sectionbody">
<div class="quoteblock abstract">
<blockquote>
A WildFly domain may consist of a new Domain Controller (DC) controlling
slave Host Controllers (HC) running older versions. Each slave HC
maintains a copy of the centralized domain configuration, which they use
for controlling their own servers. In order for the slave HCs to
understand the configuration from the DC, transformation is needed,
whereby the DC translates the configuration and operations into
something the slave HCs can understand.
</blockquote>
</div>
</div>
</div>
<div class="sect1">
<h2 id="background">Background</h2>
<div class="sectionbody">
<div class="paragraph">
<p>WildFly comes with a <a href="Admin_Guide.html#Domain_Setup">domain mode</a> which allows
you to have one Host Controller acting as the Domain Controller. The
Domain Controller&#8217;s job is to maintain the centralized domain
configuration. Another term for the DC is 'Master Host Controller'.
Before explaining why transformers are important and when they should be
used, we will revisit how the domain configuration is used in domain
mode.</p>
</div>
<div class="paragraph">
<p>The centralized domain configuration is stored in <code>domain.xml</code>. This is
only ever parsed on the DC, and it has the following structure:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>extensions</code> - contains:</p>
<div class="ulist">
<ul>
<li>
<p><code>extension</code> - a references to a module that bootstraps the
<code>org.jboss.as.controller.Extension</code> implementation used to bootstrap
your subsystem parsers and initialize the resource definitions for your
subsystems.</p>
</li>
</ul>
</div>
</li>
<li>
<p><code>profiles</code> - contains:</p>
<div class="ulist">
<ul>
<li>
<p><code>profile</code> - a named set of:</p>
<div class="ulist">
<ul>
<li>
<p><code>subsystem</code> - contains the configuration for a subsystem, using the
parser initialized by the subsystem&#8217;s extension.</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</li>
<li>
<p><code>socket-binding-groups</code> - contains:</p>
<div class="ulist">
<ul>
<li>
<p><code>socket-binding-group</code> - a named set of:</p>
<div class="ulist">
<ul>
<li>
<p><code>socket-binding</code> - A named port on an interface which can be
referenced from the <code>subsystem</code> configurations for subsystems opening
sockets.</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</li>
<li>
<p><code>server-groups</code> - contains</p>
<div class="ulist">
<ul>
<li>
<p><code>server-group</code> - this has a name and references a <code>profile</code> and a
<code>socket-binding-group</code>. The HCs then reference the <code>server-group</code> name
from their <code>&lt;servers&gt;</code> section in <code>host.xml</code>.</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
<div class="paragraph">
<p>When the DC parses <code>domain.xml</code>, it is transformed into <code>add</code> (and in
some cases <code>write-attribute</code>) operations just as explained in
<a href="Parsing_and_marshalling_of_the_subsystem_xml.html">Parsing and
marshalling of the subsystem xml</a>. These operations build up the model
on the DC.</p>
</div>
<div class="paragraph">
<p>A HC wishing to join the domain and use the DC&#8217;s centralized
configuration is known as a 'slave HC'. A slave HC maintains a copy of
the DC&#8217;s centralized domain configuration. This copy of the domain
configuration is used to start its servers. This is done by asking the
domain model to <code>describe</code> itself, which in turn asks the subsystems to
<code>describe</code> themselves. The <code>describe</code> operation for a subsystem looks at
the state of the subsystem model and produces the <code>add</code> operations
necessary to create the subsystem on the server. The same mechanism also
takes place on the DC (bear in mind that the DC is also a HC, which can
have its own servers), although of course its copy of the domain
configuration is the centralized one.</p>
</div>
<div class="paragraph">
<p>There are two steps involved in keeping the keeping the slave HC&#8217;s
domain configuration in sync with the centralized domain configuration.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>getting the initial domain model</p>
</li>
<li>
<p>an operation changes something in the domain configuration</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Let&#8217;s look a bit closer at what happens in each of these steps.</p>
</div>
<div class="sect2">
<h3 id="getting-the-initial-domain-model">Getting the initial domain model</h3>
<div class="paragraph">
<p>When a slave HC connects to the DC it obtains a copy of the domain model
from the DC. This is done in a simpler serialized format, different from
the operations that built up the model on the DC, or the operations
resulting from the <code>describe</code> step used to bootstrap the servers. They
describe each address that exists in the DC&#8217;s model, and contain the
attributes set for the resource at that address. This serialized form
looks like this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-ruby" data-lang="ruby">[{
    "domain-resource-address" =&gt; [],
    "domain-resource-model" =&gt; {
        "management-major-version" =&gt; 2,
        "management-minor-version" =&gt; 0,
        "management-micro-version" =&gt; 0,
        "release-version" =&gt; "8.0.0.Beta1-SNAPSHOT",
        "release-codename" =&gt; "WildFly"
    }
},
{
    "domain-resource-address" =&gt; [("extension" =&gt; "org.jboss.as.clustering.infinispan")],
    "domain-resource-model" =&gt; {"module" =&gt; "org.jboss.as.clustering.infinispan"}
},
--SNIP - the rest of the extensions --
{
    "domain-resource-address" =&gt; [("extension" =&gt; "org.jboss.as.weld")],
    "domain-resource-model" =&gt; {"module" =&gt; "org.jboss.as.weld"}
},
{
    "domain-resource-address" =&gt; [("system-property" =&gt; "java.net.preferIPv4Stack")],
    "domain-resource-model" =&gt; {
        "value" =&gt; "true",
        "boot-time" =&gt; undefined
    }
},
{
    "domain-resource-address" =&gt; [("profile" =&gt; "full-ha")],
    "domain-resource-model" =&gt; undefined
},
{
    "domain-resource-address" =&gt; [
        ("profile" =&gt; "full-ha"),
        ("subsystem" =&gt; "logging")
    ],
    "domain-resource-model" =&gt; {}
},
{
    "domain-resource-address" =&gt; [sss|WFLY8:Example subsystem],
    "domain-resource-model" =&gt; {
        "level" =&gt; "INFO",
        "enabled" =&gt; undefined,
        "encoding" =&gt; undefined,
        "formatter" =&gt; "%d{HH:mm:ss,SSS} %-5p [%c] (%t) %s%E%n",
        "filter-spec" =&gt; undefined,
        "autoflush" =&gt; undefined,
        "target" =&gt; undefined,
        "named-formatter" =&gt; undefined
    }
},
--SNIP---</code></pre>
</div>
</div>
<div class="paragraph">
<p>The slave HC then applies these one at a time and builds up the initial
domain model. It needs to do this before it can start any of its
servers.</p>
</div>
</div>
<div class="sect2">
<h3 id="an-operation-changes-something-in-the-domain-configuration">An operation changes something in the domain configuration</h3>
<div class="paragraph">
<p>Once a domain is up and running we can still change things in the domain
configuration. These changes must happen when connected to the DC, and
are then propagated to the slave HCs, which then in turn propagate the
changes to any servers running in a server group affected by the changes
made. In this example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-ruby" data-lang="ruby">[disconnected /] connect
[domain@localhost:9990 /] /profile=full/subsystem=datasources/data-source=ExampleDS:write-attribute(name=enabled,value=false)
{
    "outcome" =&gt; "success",
    "result" =&gt; undefined,
    "server-groups" =&gt; {"main-server-group" =&gt; {"host" =&gt; {
        "slave" =&gt; {"server-one" =&gt; {"response" =&gt; {
            "outcome" =&gt; "success",
            "result" =&gt; undefined,
            "response-headers" =&gt; {
                "operation-requires-restart" =&gt; true,
                "process-state" =&gt; "restart-required"
            }
        }}},
        "master" =&gt; {
            "server-one" =&gt; {"response" =&gt; {
                "outcome" =&gt; "success",
                "response-headers" =&gt; {
                    "operation-requires-restart" =&gt; true,
                    "process-state" =&gt; "restart-required"
                }
            }},
            "server-two" =&gt; {"response" =&gt; {
                "outcome" =&gt; "success",
                "response-headers" =&gt; {
                    "operation-requires-restart" =&gt; true,
                    "process-state" =&gt; "restart-required"
                }
            }}
        }
    }}}
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>the DC propagates the changes to itself <code>host=master</code>, which in turn
propagates it to its two servers belonging to <code>main-server-group</code> which
uses the <code>full</code> profile. More interestingly, it also propagates it to
<code>host=slave</code> which updates its local copy of the domain model, and then
propagates the change to its <code>server-one</code> which belongs to
<code>main-server-group</code> which uses the <code>full</code> profile.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="versions-and-backward-compatibility">Versions and backward compatibility</h2>
<div class="sectionbody">
<div class="paragraph">
<p>A HC and its servers will always be the same version of WildFly (they
use the same module path and jars). However, the DC and the slave HCs do
not necessarily need to be the same version. One of the points in the
original specification for WildFly is that</p>
</div>
<div class="paragraph">
<p>Important</p>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<div class="title">Important</div>
</td>
<td class="content">
A Domain Controller should be able to manage slave Host Controllers
older than itself.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>This means that for example a WildFly 10.1 DC should be able to work
with slave HCs running WildFly 10. The opposite is not true, the DC must
be the same or the newest version in the domain.</p>
</div>
<div class="sect2">
<h3 id="versioning-of-subsystems">Versioning of subsystems</h3>
<div class="paragraph">
<p>To help with being able to know what is compatible we have versions
within the subsystems, this is stored in the subsystem&#8217;s extension. When
registering the subsystem you will typically see something like:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">public class SomeExtension implements Extension {
 
    private static final String SUBSYSTEM_NAME = "my-subsystem"'
 
    private static final int MANAGEMENT_API_MAJOR_VERSION = 2;
    private static final int MANAGEMENT_API_MINOR_VERSION = 0;
    private static final int MANAGEMENT_API_MICRO_VERSION = 0;
 
    /**
     * {@inheritDoc}
     * @see org.jboss.as.controller.Extension#initialize(org.jboss.as.controller.ExtensionContext)
     */
    @Override
    public void initialize(ExtensionContext context) {
 
        // IMPORTANT: Management API version != xsd version! Not all Management API changes result in XSD changes
        SubsystemRegistration registration = context.registerSubsystem(SUBSYSTEM_NAME, MANAGEMENT_API_MAJOR_VERSION,
                MANAGEMENT_API_MINOR_VERSION, MANAGEMENT_API_MICRO_VERSION);
 
        //Register the resource definitions
        ....
    }
    ....
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Which sets the <code>ModelVersion</code> of the subsystem.</p>
</div>
<div class="paragraph">
<p>Important</p>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<div class="title">Important</div>
</td>
<td class="content">
Whenever something changes in the subsystem, such as:
</td>
</tr>
</table>
</div>
<div class="ulist">
<ul>
<li>
<p>an attribute is added or removed from a resource</p>
</li>
<li>
<p>a attribute is renamed in a resource</p>
</li>
<li>
<p>an attribute has its type changed</p>
</li>
<li>
<p>an attribute or operation parameter&#8217;s nillable or allows expressions
is changed</p>
</li>
<li>
<p>an attribute or operation parameter&#8217;s default value changes</p>
</li>
<li>
<p>a child resource type is added or removed</p>
</li>
<li>
<p>an operation is added or removed</p>
</li>
<li>
<p>an operation has its parameters changed</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>and the current version of the subsystem has been part of a Final
release of WildFly, we <strong>must</strong> bump the version of the subsystem.</p>
</div>
<div class="paragraph">
<p>Once it has been increased you can of course make more changes until the
next Final release without more version bumps. It is also worth noting
that a new WildFly release does not automatically mean a new version for
the subsystem, the new version is only needed if something was changed.
For example the <code>jaxrs</code> subsystem has remained on 1.0.0 for all versions
of WildFly and JBoss AS 7.</p>
</div>
<div class="paragraph">
<p>You can find the <code>ModelVersion</code> of a subsystem by querying its
extension:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-ruby" data-lang="ruby">domain@localhost:9990 /] /extension=org.jboss.as.clustering.infinispan:read-resource(recursive=true)
{
    "outcome" =&gt; "success",
    "result" =&gt; {
        "module" =&gt; "org.jboss.as.clustering.infinispan",
        "subsystem" =&gt; {"infinispan" =&gt; {
            "management-major-version" =&gt; 2,
            "management-micro-version" =&gt; 0,
            "management-minor-version" =&gt; 0,
            "xml-namespaces" =&gt; [jboss:domain:infinispan:1.0",
                "urn:jboss:domain:infinispan:1.1",
                "urn:jboss:domain:infinispan:1.2",
                "urn:jboss:domain:infinispan:1.3",
                "urn:jboss:domain:infinispan:1.4",
                "urn:jboss:domain:infinispan:2.0"]
        }}
    }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="the-role-of-transformers">The role of transformers</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Now that we have mentioned the slave HCs registration process with the
DC, and know about ModelVersions, it is time to mention that when
registering with the DC, the slave HC will send across a list of all its
subsystem ModelVersions. The DC maintains this information in a registry
for each slave HC, so that it knows which transformers (if any) to
invoke for a legacy slave. We will see how to write and register
transformers later on in
<a href="#how-do-i-write-a-transformer">#How
do I write a transformer</a>. Slave HCs from version 7.2.0 onwards will
also include a list of resources that they ignore (see
<a href="#ignoring-resources-on-legacy-hosts">#Ignoring
resources on legacy hosts</a>), and the DC will maintain this information
in its registry. The DC will not send across any resources that it knows
a slave ignores during the initial domain model transfer. When
forwarding operations onto the slave HCs, the DC will skip forwarding
those to slave HCs ignoring those resources.</p>
</div>
<div class="paragraph">
<p>There are two kinds of transformers:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>resource transformers</p>
</li>
<li>
<p>operation transformers</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The main function of transformers is to transform a subsystem to
something that the legacy slave HC can understand, or to aggressively
reject things that the legacy slave HC will not understand. Rejection,
in this context, essentially means, that the resource or operation
cannot safely be transformed to something valid on the slave, so the
transformation fails. We will see later how to reject attributes in
<a href="#rejecting-attributes">#Rejecting
attributes</a>, and child resources in
<a href="#reject-child-resource">#Reject
child resource</a>.</p>
</div>
<div class="paragraph">
<p>Both resource and operation transformers are needed, but take effect at
different times. Let us use the <code>weld</code> subsystem, which is relatively
simple, as an example. In JBoss AS 7.2.0 and lower it had a ModelVersion
of 1.0.0, and its resource description was as follows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-ruby" data-lang="ruby">                {
                    "description" =&gt; "The configuration of the weld subsystem.",
                    "attributes" =&gt; {},
                    "operations" =&gt; {
                        "remove" =&gt; {
                            "operation-name" =&gt; "remove",
                            "description" =&gt; "Operation removing the weld subsystem.",
                            "request-properties" =&gt; {},
                            "reply-properties" =&gt; {}
                        },
                        "add" =&gt; {
                            "operation-name" =&gt; "add",
                            "description" =&gt; "Operation creating the weld subsystem.",
                            "request-properties" =&gt; {},
                            "reply-properties" =&gt; {}
                        }
                    },
                    "children" =&gt; {}
                },</code></pre>
</div>
</div>
<div class="paragraph">
<p>In WildFly {wildflyVersion}, it has a ModelVersion of 2.0.0 and has added two
attributes, <code>require-bean-descriptor</code> and <code>non-portable</code> mode:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-ruby" data-lang="ruby">{
        "description" =&gt; "The configuration of the weld subsystem.",
        "attributes" =&gt; {
            "require-bean-descriptor" =&gt; {
                "type" =&gt; BOOLEAN,
                "description" =&gt; "If true then implicit bean archives without bean descriptor file (beans.xml) are ignored by Weld",
                "expressions-allowed" =&gt; true,
                "nillable" =&gt; true,
                "default" =&gt; false,
                "access-type" =&gt; "read-write",
                "storage" =&gt; "configuration",
                "restart-required" =&gt; "no-services"
            },
            "non-portable-mode" =&gt; {
                "type" =&gt; BOOLEAN,
                "description" =&gt; "If true then the non-portable mode is enabled. The non-portable mode is suggested by the specification to overcome problems with legacy applications that do not use CDI SPI properly and may be rejected by more strict validation in CDI 1.1.",
                "expressions-allowed" =&gt; true,
                "nillable" =&gt; true,
                "default" =&gt; false,
                "access-type" =&gt; "read-write",
                "storage" =&gt; "configuration",
                "restart-required" =&gt; "no-services"
            }
        },
        "operations" =&gt; {
            "remove" =&gt; {
                "operation-name" =&gt; "remove",
                "description" =&gt; "Operation removing the weld subsystem.",
                "request-properties" =&gt; {},
                "reply-properties" =&gt; {}
            },
            "add" =&gt; {
                "operation-name" =&gt; "add",
                "description" =&gt; "Operation creating the weld subsystem.",
                "request-properties" =&gt; {
                    "require-bean-descriptor" =&gt; {
                        "type" =&gt; BOOLEAN,
                        "description" =&gt; "If true then implicit bean archives without bean descriptor file (beans.xml) are ignored by Weld",
                        "expressions-allowed" =&gt; true,
                        "required" =&gt; false,
                        "nillable" =&gt; true,
                        "default" =&gt; false
                    },
                    "non-portable-mode" =&gt; {
                        "type" =&gt; BOOLEAN,
                        "description" =&gt; "If true then the non-portable mode is enabled. The non-portable mode is suggested by the specification to overcome problems with legacy applications that do not use CDI SPI properly and may be rejected by more strict validation in CDI 1.1.",
                        "expressions-allowed" =&gt; true,
                        "required" =&gt; false,
                        "nillable" =&gt; true,
                        "default" =&gt; false
                    }
                },
                "reply-properties" =&gt; {}
            }
        },
        "children" =&gt; {}
    }</code></pre>
</div>
</div>
<div class="paragraph">
<p>In the rest of this section we will assume that we are running a DC
running WildFly {wildflyVersion} so it will have ModelVersion 2.0.0 of the weld
subsystem, and that we are running a slave using ModelVersion 1.0.0 of
the weld subsystem.</p>
</div>
<div class="paragraph">
<p>Important</p>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<div class="title">Important</div>
</td>
<td class="content">
Transformation always takes place on the Domain Controller, and is done
when sending across the initial domain model AND forwarding on
operations to legacy slave HCs.
</td>
</tr>
</table>
</div>
<div class="sect2">
<h3 id="resource-transformers">Resource transformers</h3>
<div class="paragraph">
<p>When copying over the centralized domain configuration as mentioned in
<a href="#getting-the-initial-domain-model">#Getting
the initial domain model</a>, we need to make sure that the copy of the
domain model is something that the servers running on the legacy slave
HC understand. So if the centralized domain configuration had any of the
two new attributes set, we would need to reject the transformation in
the transformers. One reason for this is to keep things consistent, it
doesn&#8217;t look good if you connect to the slave HC and find attributes
and/or child resources when doing <code>:read-resource</code> which are not there
when you do <code>:read-resource-description</code>. Also, to make life easier for
subsystem writers, most instances of the <code>describe</code> operation use a
standard implementation which would include these attributes when
creating the <code>add</code> operation for the server, which could cause problems
there.</p>
</div>
<div class="paragraph">
<p>Another, more concrete example from the logging subsystem is that it
allows a ' <code>%K{&#8230;&#8203;</code>}' in the pattern formatter which makes the formatter
use color:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-xml" data-lang="xml">            &lt;pattern-formatter pattern="%K{level}%d{HH:mm:ss,SSS} %-5p [%c] (%t) %s%E%n"/&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>This ' <code>%K{&#8230;&#8203;</code>}' however was introduced in JBoss AS &lt; 7.1.3
(ModelVersion 1.2.0), so if that makes it across to a slave HC running
an older version, the servers <strong>will</strong> fail to start up. So the logging
extension registers transformers to strip out the ' <code>%K{&#8230;&#8203;</code>}' from the
attribute value (leaving ' <code>%-5p</code> <code>%c</code> `(%t) %s%E%n"&#8217;) so that the old
slave HC&#8217;s servers can understand it.</p>
</div>
<div class="sect3">
<h4 id="rejection-in-resource-transformers">Rejection in resource transformers</h4>
<div class="paragraph">
<p>Only slave HCs from JBoss AS 7.2.0 and newer inform the DC about their
ignored resources (see
<a href="#ignoring-resources-on-legacy-hosts">#Ignoring
resources on legacy hosts</a>). This means that if a transformer on the DC
rejects transformation for a legacy slave HC, exactly what happens to
the slave HC depends on the version of the slave HC. If the slave HC is:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><em>older than 7.2.0</em> - the DC has no means of knowing if the slave HC
has ignored the resource being rejected or not. So we log a warning on
the DC, and send over the serialized part of that model anyway. If the
slave HC has ignored the resource in question, it does not apply it. If
the slave HC has not ignored the resource in question, it will apply it,
but no failure will happen until it tries to start a server which
references this bad configuration.</p>
</li>
<li>
<p><em>7.2.0 or newer</em> - If a resource is ignored on the slave HC, the DC
knows about this, and will not attempt to transform or send the resource
across to the slave HC. If the resource transformation is rejected, we
know the resource was not ignored on the slave HC and so we can
aggressively fail the transformation, which in turn will cause the slave
HC to fail to start up.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect2">
<h3 id="operation-transformers">Operation transformers</h3>
<div class="paragraph">
<p>When
<a href="#an-operation-changes-something-in-the-domain-configuration">#An
operation changes something in the domain configuration</a> the operation
gets sent across to the slave HCs to update their copies of the domain
model. The slave HCs then forward this operation onto the affected
servers. The same considerations as in
<a href="#resource-transformers">#Resource
transformers</a> are true, although operation transformers give you quicker
'feedback' if something is not valid. If you try to execute:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-ruby" data-lang="ruby">/profile=full/subsystem=weld:write-attribute(name=require-bean-descriptor, value=false)</code></pre>
</div>
</div>
<div class="paragraph">
<p>This will fail on the legacy slave HC since its version of the subsystem
does not contain any such attribute. However, it is best to aggressively
reject in such cases.</p>
</div>
<div class="sect3">
<h4 id="rejection-in-operation-transformers">Rejection in operation transformers</h4>
<div class="paragraph">
<p>For transformed operations we can always know if the operation is on an
ignored resource in the legacy slave HC. In 7.2.0 onwards, we know this
through the DC&#8217;s registry of ignored resources on the slave. In older
versions of slaves, we send the operation across to the slave, which
tries to invoke the operation. If the operation is against an ignored
resource we inform the DC about this fact. So as part of the
transformation process, if something gets rejected we can (and do!) fail
the transformation aggressively. If the operation invoked on the DC
results in the operation being sent across to 10 slave HCs and one of
them has a legacy version which ends up rejecting the transformation, we
rollback the operation across the whole domain.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="different-profiles-for-different-versions">Different profiles for different versions</h3>
<div class="paragraph">
<p>Now for the <code>weld</code> example we have been using there is a slight twist.
We have the new <code>require-bean-descriptor</code> and <code>non-portable-mode</code>
attributes. These have been added in WildFly {wildflyVersion} which supports Java EE 7,
and thus CDI 1.1. JBoss AS 7.x supports Java EE 6, and thus CDI 1.0. In
CDI 1.1 the values of these attributes are tweakable, so they can be set
to either <code>true</code> or <code>false</code>. The default behaviour for these in CDI 1.1,
if not set, is that they are <code>false</code>. However, for CDI 1.0 these were
not tweakable, and with the way the subsystem in JBoss AS 7.x worked is
similar to if they are set to <code>true</code>.</p>
</div>
<div class="paragraph">
<p>The above discussion implies that to use the weld subsystem on a legacy
slave HC, the <code>domain.xml</code> configuration for it must look like:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-xml" data-lang="xml">&lt;subsystem xmlns="urn:jboss:domain:weld:2.0"
      require-bean-descriptor="true"
      non-portable-mode="true"/&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>We will see the exact mechanics for how this is actually done later but
in short when pushing this to a legacy slave DC we register transformers
which reject the transformation if these attributes are not set to
<code>true</code> since that implies some behavior not supported on the legacy
slave DC. If they are <code>true</code>, all is well, and the transformers discard,
or remove, these attributes since they don&#8217;t exist in the legacy model.
This removal is fine since they have the values which would result in
the behavior assumed on the legacy slave HC.</p>
</div>
<div class="paragraph">
<p>That way the older slave HCs will work fine. However, we might also have
WildFly {wildflyVersion} slave HCs in our domain, and they are missing out on the new
features introduced by the attributes introduced in ModelVersion 2.0.0.
If we do</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-xml" data-lang="xml">&lt;subsystem xmlns="urn:jboss:domain:weld:2.0"
      require-bean-descriptor="false"
      non-portable-mode="false"/&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>then it will fail when doing transformation for the legacy controller.
The solution is to put these in two different profiles in <code>domain.xml</code></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-xml" data-lang="xml">&lt;domain&gt;
....
  &lt;profiles&gt;
    &lt;profile name="full"&gt;
      &lt;subsystem xmlns="urn:jboss:domain:weld:2.0"
        require-bean-descriptor="false"
        non-portable-mode="false"/&gt;
      ...
    &lt;/profile&gt;
    &lt;profile name="full-legacy"&gt;
      &lt;subsystem xmlns="urn:jboss:domain:weld:2.0"
        require-bean-descriptor="true"
        non-portable-mode="true"/&gt;
      ...
    &lt;/profile&gt;
  &lt;/profiles&gt;
  ...
  &lt;server-groups&gt;
    &lt;server-group name="main-server-group" profile="full"&gt;
      ....
    &lt;server-group&gt;
    &lt;server-group name="main-server-group-legacy" profile="full-legacy"&gt;
      ....
    &lt;server-group&gt;
  &lt;/server-groups&gt;
&lt;/domain&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Then have the HCs using WildFly {wildflyVersion} make their servers reference the
<code>main-server-group</code> server group, and the HCs using older versions of
WildFly {wildflyVersion} make their servers reference the <code>main-server-group-legacy</code>
server group.</p>
</div>
<div class="sect3">
<h4 id="ignoring-resources-on-legacy-hosts">Ignoring resources on legacy hosts</h4>
<div class="paragraph">
<p>Booting the above configuration will still cause problems on legacy
slave HCs, especially if they are JBoss AS 7.2.0 or later. The reason
for this is that when they register themselves with the DC it lets the
DC know which <code>ignored resources</code> they have. If the DC comes to
transform something it should reject for a slave HC and it is not part
of its ignored resources it will aggressively fail the transformation.
Versions of JBoss AS older than 7.2.0 still have this ignored resources
mechanism, but don&#8217;t let the DC know about what they have ignored so the
DC cannot reject aggressively - instead it will log some warnings.
However, it is still good practice to ignore resources you are not
interested in regardless of which legacy version the slave HC is
running.</p>
</div>
<div class="paragraph">
<p>To ignore the profile we cannot understand we do the following in the
legacy slave HC&#8217;s <code>host.xml</code></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-xml" data-lang="xml">&lt;host xmlns="urn:jboss:domain:1.3" name="slave"&gt;
...
    &lt;domain-controller&gt;
       &lt;remote host="${jboss.test.host.master.address}" port="${jboss.domain.master.port:9999}" security-realm="ManagementRealm"&gt;
            &lt;ignored-resources type="profile"&gt;
                &lt;instance name="full-legacy"/&gt;
            &lt;/ignored-resources&gt;
       &lt;/remote&gt;
    &lt;/domain-controller&gt;
....
&lt;/host&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Important</p>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<div class="title">Important</div>
</td>
<td class="content">
Any top-level resource type can be ignored <code>profile</code>, <code>extension</code>,
<code>server-group</code> etc. Ignoring a resource instance ignores that resource,
and all its children.
</td>
</tr>
</table>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="how-do-i-know-what-needs-to-be-transformed">How do I know what needs to be transformed?</h2>
<div class="sectionbody">
<div class="paragraph">
<p>There is a set of related classes in the <code>org.wildfly.legacy.util</code>
package to help you determine this. These now live at
<a href="https://github.com/wildfly/wildfly-legacy-test/tree/master/tools/src/main/java/org/wildfly/legacy/util" class="bare">https://github.com/wildfly/wildfly-legacy-test/tree/master/tools/src/main/java/org/wildfly/legacy/util</a>.<br>
They are all runnable in your IDE, just start the WildFly or JBoss AS 7
instances as described below.</p>
</div>
<div class="sect2">
<h3 id="getting-data-for-a-previous-version">Getting data for a previous version</h3>
<div class="paragraph">
<p><a href="https://github.com/wildfly/wildfly-legacy-test/tree/master/tools/src/main/resources/legacy-models" class="bare">https://github.com/wildfly/wildfly-legacy-test/tree/master/tools/src/main/resources/legacy-models</a>
contains the output for the previous WildFly/JBoss AS 7 versions, so
check if the files for the version you want to check backwards
compatibility are there yet. If not, then you need to do the following
to get the subsystem definitions:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Start the <strong>old</strong> version of WildFly/JBoss AS 7 using
<code>--server-config=standalone-full-ha.xml</code></p>
</li>
<li>
<p>Run <code>org.wildfly.legacy.util.GrabModelVersionsUtil</code>, which will
output the subsystem versions to
<code>target/standalone-model-versions-running.dmr</code></p>
</li>
<li>
<p>Run <code>org.wildfly.legacy.util.DumpStandaloneResourceDefinitionUtil</code>
which will output the full resource definition to
<code>target/standalone-resource-definition-running.dmr</code></p>
</li>
<li>
<p>Stop the running version of WildFly/JBoss AS 7</p>
</li>
</ol>
</div>
</div>
<div class="sect2">
<h3 id="see-what-changed">See what changed</h3>
<div class="paragraph">
<p>To do this follow the following steps</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Start the <strong>new</strong> version of WildFly using
<code>--server-config=standalone-full-ha.xml</code></p>
</li>
<li>
<p>Run <code>org.wildfly.legacy.util.CompareModelVersionsUtil</code> and answer
the following questions"</p>
<div class="olist loweralpha">
<ol class="loweralpha" type="a">
<li>
<p>Enter Legacy AS version:</p>
<div class="ulist">
<ul>
<li>
<p>If it is known version in the <code>tools/src/test/resources/legacy-models</code>
folder, enter the version number.</p>
</li>
<li>
<p>If it is a not known version, and you got the data yourself in the
last step, enter ' `running&#8217;</p>
</li>
</ul>
</div>
</li>
<li>
<p>Enter type:</p>
<div class="ulist">
<ul>
<li>
<p>Answer ' `S&#8217;</p>
</li>
</ul>
</div>
</li>
</ol>
</div>
</li>
<li>
<p>Read from target directory or from the legacy-models directory:</p>
<div class="ulist">
<ul>
<li>
<p>If it is known version in the
<code>controller/src/test/resources/legacy-models</code> folder, enter ' `l&#8217;.</p>
</li>
<li>
<p>If it is a not known version, and you got the data yourself in the
last step, enter ' `t&#8217;</p>
</li>
</ul>
</div>
</li>
<li>
<p>Report on differences in the model when the management versions are
different?:</p>
<div class="ulist">
<ul>
<li>
<p>Answer ' `y&#8217;</p>
</li>
</ul>
</div>
</li>
</ol>
</div>
<div class="paragraph">
<p>Here is some example output, as a subsystem developer you can ignore
everything down to <code>======= Comparing subsystem models ======</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-bash" data-lang="bash">Enter legacy AS version: 7.2.0.Final
Using target model: 7.2.0.Final
Enter type [S](standalone)/H(host)/D(domain)/F(domain + host):S
Read from target directory or from the legacy-models directory - t/[l]:
Report on differences in the model when the management versions are different? y/[n]: y
Reporting on differences in the model when the management versions are different
Loading legacy model versions for 7.2.0.Final....
Loaded legacy model versions
Loading model versions for currently running server...
Oct 01, 2013 6:26:03 PM org.xnio.Xnio &lt;clinit&gt;
INFO: XNIO version 3.1.0.CR7
Oct 01, 2013 6:26:03 PM org.xnio.nio.NioXnio &lt;clinit&gt;
INFO: XNIO NIO Implementation Version 3.1.0.CR7
Oct 01, 2013 6:26:03 PM org.jboss.remoting3.EndpointImpl &lt;clinit&gt;
INFO: JBoss Remoting version 4.0.0.Beta1
Loaded current model versions
Loading legacy resource descriptions for 7.2.0.Final....
Loaded legacy resource descriptions
Loading resource descriptions for currently running STANDALONE...
Loaded current resource descriptions
Starting comparison of the current....
 
======= Comparing core models ======
-- SNIP --
 
======= Comparing subsystem models ======
-- SNIP --
======= Resource root address: ["subsystem" =&gt; "remoting"] - Current version: 2.0.0; legacy version: 1.2.0 =======
--- Problems for relative address to root []:
Missing child types in current: []; missing in legacy [http-connector]
--- Problems for relative address to root ["remote-outbound-connection" =&gt; "*"]:
Missing attributes in current: []; missing in legacy [protocol]
Missing parameters for operation 'add' in current: []; missing in legacy [protocol]
-- SNIP --
======= Resource root address: ["subsystem" =&gt; "weld"] - Current version: 2.0.0; legacy version: 1.0.0 =======
--- Problems for relative address to root []:
Missing attributes in current: []; missing in legacy [require-bean-descriptor, non-portable-mode]
Missing parameters for operation 'add' in current: []; missing in legacy [require-bean-descriptor, non-portable-mode]
 
Done comparison of STANDALONE!</code></pre>
</div>
</div>
<div class="paragraph">
<p>So we can see that for the <code>remoting</code> subsystem, we have added a child
type called <code>http-connector</code>, and we have added an attribute called
<code>protocol</code> (they are missing in legacy).<br>
in the <code>weld</code> subsystem, we have added the <code>require-bean-descriptor</code> and
<code>non-portable-mode</code> attributes in the current version. It will also
point out other issues like changed attribute types, changed defaults
etc.</p>
</div>
<div class="paragraph">
<p>Warning</p>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<div class="title">Warning</div>
</td>
<td class="content">
Note that CompareModelVersionsUtil simply inspects the raw resource
descriptions of the specified legacy and current models. Its results
show the differences between the two. They do not take into account
whether one or more transformers have already been written for those
versions differences. You will need to check that transformers are not
already in place for those versions.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>One final point to consider are that some subsystems register
runtime-only resources and operations. For example the <code>modcluster</code>
subsystem has a <code>stop</code> method. These do not get registered on the <code>DC</code>,
e.g. there is no <code>/profile=full-ha/subsystem=modcluster:stop</code> operation,
it only exists on the servers, for example
<code>/host=xxx/server=server-one/subsystem=modcluster:stop</code>. What this means
is that you don&#8217;t have to transform such operations and resources. The
reason is they are not callable on the DC, and so do not need
propagation to the servers in the domain, which in turn means no
transformation is needed.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="how-do-i-write-a-transformer">How do I write a transformer?</h2>
<div class="sectionbody">
<div class="paragraph">
<p>There are two APIs available to write transformers for a resource. There
is the original low-level API where you register transformers directly,
the general idea is that you get hold of a <code>TransformersSubRegistration</code>
for each level and implement the <code>ResourceTransformer</code>,
<code>OperationTransformer</code> and <code>PathAddressTransformer</code> interfaces directly.
It is, however, a pretty complex thing to do, so we recommend the other
approach. For completeness here is the entry point to handling
transformation in this way.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">public class SomeExtension implements Extension {
 
    private static final String SUBSYSTEM_NAME = "my-subsystem"'
 
    private static final int MANAGEMENT_API_MAJOR_VERSION = 2;
    private static final int MANAGEMENT_API_MINOR_VERSION = 0;
    private static final int MANAGEMENT_API_MICRO_VERSION = 0;
 
    @Override
    public void initialize(ExtensionContext context) {
        SubsystemRegistration registration = context.registerSubsystem(SUBSYSTEM_NAME, MANAGEMENT_API_MAJOR_VERSION,
                MANAGEMENT_API_MINOR_VERSION, MANAGEMENT_API_MICRO_VERSION);
        //Register the resource definitions
        ....
    }
 
    static void registerTransformers(final SubsystemRegistration subsystem) {
        registerTransformers_1_1_0(subsystem);
        registerTransformers_1_2_0(subsystem);
    }
 
    /**
     * Registers transformers from the current version to ModelVersion 1.1.0
     */
    private static void registerTransformers_1_1_0(final SubsystemRegistration subsystem) {
        final ModelVersion version = ModelVersion.create(1, 1, 0);
 
        //The default resource transformer forwards all operations
        final TransformersSubRegistration registration = subsystem.registerModelTransformers(version, ResourceTransformer.DEFAULT);
        final TransformersSubRegistration child = registration.registerSubResource(PathElement.pathElement("child"));
        //We can do more things on the TransformersSubRegistation instances
 
 
        registerRelayTransformers(stack);
    }</code></pre>
</div>
</div>
<div class="paragraph">
<p>Having implemented a number of transformers using the above approach, we
decided to simplify things, so we introduced the
<code>org.jboss.as.controller.transform.description.ResourceTransformationDescriptionBuilder</code>
API. It is a lot simpler and avoids a lot of the duplication of
functionality required by the low-level API approach. While it doesn&#8217;t
give you the full power that the low-level API does, we found that there
are very few places in the WildFly codebase where this does not work, so
we will focus on the <code>ResourceTransformationDescriptionBuilder</code> API
here. (If you come across a problem where this does not work, get in
touch with someone from the WildFly Domain Management Team and we should
be able to help). The builder API makes all the nasty calls to
<code>TransformersSubRegistration</code> for you under the hood. It also allows you
to fall back to the low-level API in places, although that will not be
covered in the current version of this guide. The entry point for using
the builder API here is taken from the WeldExtension (in current WildFly
this has ModelVersion 2.0.0).</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">    private void registerTransformers(SubsystemRegistration subsystem) {
        ResourceTransformationDescriptionBuilder builder = TransformationDescriptionBuilder.Factory.createSubsystemInstance();
        //These new attributes are assumed to be 'true' in the old version but default to false in the current version. So discard if 'true' and reject if 'undefined'.
        builder.getAttributeBuilder()
                .setDiscard(new DiscardAttributeChecker.DiscardAttributeValueChecker(false, false, new ModelNode(true)),
                        WeldResourceDefinition.NON_PORTABLE_MODE_ATTRIBUTE, WeldResourceDefinition.REQUIRE_BEAN_DESCRIPTOR_ATTRIBUTE)
                .addRejectCheck(new RejectAttributeChecker.DefaultRejectAttributeChecker() {
 
                    @Override
                    public String getRejectionLogMessage(Map&lt;String, ModelNode&gt; attributes) {
                        return WeldMessages.MESSAGES.rejectAttributesMustBeTrue(attributes.keySet());
                    }
 
                    @Override
                    protected boolean rejectAttribute(PathAddress address, String attributeName, ModelNode attributeValue,
                            TransformationContext context) {
                        //This will not get called if it was discarded, so reject if it is undefined (default==false) or if defined and != 'true'
                        return !attributeValue.isDefined() || !attributeValue.asString().equals("true");
                    }
                }, WeldResourceDefinition.NON_PORTABLE_MODE_ATTRIBUTE, WeldResourceDefinition.REQUIRE_BEAN_DESCRIPTOR_ATTRIBUTE)
                .end();
        TransformationDescription.Tools.register(builder.build(), subsystem, ModelVersion.create(1, 0, 0));
    }</code></pre>
</div>
</div>
<div class="paragraph">
<p>Here we register a <code>discard check</code> and a <code>reject check</code>. As mentioned in
<a href="#attribute-transformation-lifecycle">#Attribute
transformation lifecycle</a> all attributes are inspected for whether they
should be discarded first. Then all attributes which were not discarded
are checked for if they should be rejected. We will dig more into what
this code means in the next few sections, but in short it means that we
discard the <code>require-bean-descriptor</code> and <code>non-portable</code> attributes on
the <code>weld</code> subsystem resource if they have the value <code>true</code>. If they
have any other value, they will not get discarded and so reach the
reject check, which will reject the transformation of the attributes if
they have any other value.</p>
</div>
<div class="paragraph">
<p>Here we are saying that we should discard the <code>require-bean-descriptor</code>
and <code>non-portable-mode</code> attributes on the <code>weld</code> subsystem resource if
they are undefined, and reject them if they are defined. So that means
that if the weld subsystem looks like</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">    {
        "non-portable-mode" =&gt; false,
        "require-bean-descriptor" =&gt; false
    }</code></pre>
</div>
</div>
<div class="paragraph">
<p>or</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">    {
        "non-portable-mode" =&gt; undefined,
        "require-bean-descriptor" =&gt; undefined
    }</code></pre>
</div>
</div>
<div class="paragraph">
<p>or any other combination (the default values for these attributes if
undefined is <code>false</code>) we will reject the transformation for the slave
legacy HC.</p>
</div>
<div class="paragraph">
<p>If the resource has true for these attributes:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">    {
        "non-portable-mode" =&gt; true,
        "require-bean-descriptor" =&gt; true
    }</code></pre>
</div>
</div>
<div class="paragraph">
<p>they both get discarded (i.e. removed), so they will not get inspected
for rejection, and an empty model not containing these attributes gets
sent to the legacy HC.</p>
</div>
<div class="paragraph">
<p>Here we will discuss this API a bit more, to outline the most important
features/most commonly needed tasks.</p>
</div>
<div class="sect2">
<h3 id="resourcetransformationdescriptionbuilder">ResourceTransformationDescriptionBuilder</h3>
<div class="paragraph">
<p>The <code>ResourceTransformationDescriptionBuilder</code> contains transformations
for a resource type. The initial one is for the subsystem, obtained by
the following call:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">        ResourceTransformationDescriptionBuilder subsystemBuilder = TransformationDescriptionBuilder.Factory.createSubsystemInstance();</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>ResourceTransformationDescriptionBuilder</code> contains functionality
for how to handle child resources, which we will look at in this
section. It is also the entry point to how to handle transformation of
attributes as we will see in
<a href="#attributetransformationdescriptionbuilder">#AttributeTransformationDescriptionBuilder</a>.
Also, it allows you to further override operation transformation as
discussed in
<a href="#operationtransformationoverridebuilder">#OperationTransformationOverrideBuilder</a>.
When we have finished with our builder, we register it with the
<code>SubsystemRegistration</code> against the target ModelVersion.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">        TransformationDescription.Tools.register(subsystemBuilder.build(), subsystem, ModelVersion.create(1, 0, 0));</code></pre>
</div>
</div>
<div class="paragraph">
<p>Important</p>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<div class="title">Important</div>
</td>
<td class="content">
If you have several old ModelVersions you could be transforming to, you
need a separate builder for each of those.
</td>
</tr>
</table>
</div>
<div class="sect3">
<h4 id="silently-discard-child-resources">Silently discard child resources</h4>
<div class="paragraph">
<p>To make the <code>ResourceTransformationDescriptionBuilder</code> do something, we
need to call some of its methods. For example, if we want to silently
discard a child resource, we can do</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">    subsystemBuilder.discardChildResource(PathElement.pathElement("child", "discarded"));</code></pre>
</div>
</div>
<div class="paragraph">
<p>This means that any usage of <code>/subsystem=my-subsystem/child=discarded</code>
never make it to the legacy slave HC running ModelVersion 1.0.0. During
the initial domain model transfer, that part of the serialized domain
model is stripped out, and any operations on this address are not
forwarded on to the legacy slave HCs running that version of the
subsystem. (For brevity this section will leave out the leading
<code>/profile=xxx</code> part used in domain mode, and use
<code>/subsystem=my-subsystem</code> as the 'top-level' address).</p>
</div>
<div class="paragraph">
<p>Warning</p>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<div class="title">Warning</div>
</td>
<td class="content">
Note that discarding, although the simplest option in theory, is <strong>rarely
the right thing to do</strong>.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The presence of the defined child normally implies some behaviour on the
DC, and that behaviour is not available on the legacy slave HC, so
normally rejection is a better policy for those cases. Remember we can
have different profiles targeting different groups of versions of legacy
slave HCs.</p>
</div>
</div>
<div class="sect3">
<h4 id="reject-child-resource">Reject child resource</h4>
<div class="paragraph">
<p>If we want to reject transformation if a child resource exists, we can
do</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">    subsystemBuilder.rejectChildResource(PathElement.pathElement("child", "reject"));</code></pre>
</div>
</div>
<div class="paragraph">
<p>Now, if there are any legacy slaves running ModelVersion 1.0.0, any
usage of <code>/subsystem=my-subsystem/child=reject</code> will get rejected for
those slaves. Both during the initial domain model transfer, and if any
operations are invoked on that address. For example the <code>remoting</code>
subsystem did not have a <code>http-connector=*</code> child until ModelVersion
2.0.0, so it is set up to reject that child when transforming to legacy
HCs for all previous ModelVersions (1.1.0, 1.2.0 and 1.3.0). (See
<a href="#rejection-in-resource-transformers">#Rejection
in resource transformers</a> and
<a href="#rejection-in-operation-transformers">#Rejection
in operation transformers</a> for exactly what happens when something is
rejected).</p>
</div>
</div>
<div class="sect3">
<h4 id="redirect-address-for-child-resource">Redirect address for child resource</h4>
<div class="paragraph">
<p>Sometimes we rename the addresses for a child resource between model
versions. To do that we use one of the <code>addChildRedirection()</code> methods,
note that these also return a builder for the child resource (since we
are not rejecting or discarding it), we can do this for all children of
a given type:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">    ResourceTransformationDescriptionBuilder childBuilder =
       subsystemBuilder.addChildRedirection(PathElement.pathElement("newChild"), PathElement.pathElement("oldChild");</code></pre>
</div>
</div>
<div class="paragraph">
<p>Now, in the initial domain transfer
<code>/subsystem=my-subsystem/newChild=test</code> becomes
<code>/subsystem=my-subsystem/oldChild=test</code>. Similarly all operations
against the former address get mapped to the latter when executing
operations on the DC before sending them to the legacy slave HC running
ModelVersion 1.1.0 of the subsystem.</p>
</div>
<div class="paragraph">
<p>We can also rename a specific named child:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">    ResourceTransformationDescriptionBuilder childBuilder =
       subsystemBuilder.addChildRedirection(PathElement.pathElement("newChild", "newName"), PathElement.pathElement("oldChild", "oldName");</code></pre>
</div>
</div>
<div class="paragraph">
<p>Now, <code>/subsystem=my-subsystem/newChild=newName</code> becomes
<code>/subsystem=my-subsystem/oldChild=oldName</code> both in the initial domain
transfer, and when mapping operations to the legacy slave. For example,
under the <code>web</code> subsystem <code>ssl=configuration</code> got renamed to
<code>configuration=ssl</code> in later versions, meaning we need a redirect from
<code>configuration=ssl</code> to <code>ssl=configuration</code> in its transformers.</p>
</div>
</div>
<div class="sect3">
<h4 id="getting-a-child-resource-builder">Getting a child resource builder</h4>
<div class="paragraph">
<p>Sometimes we don&#8217;t want to transform the subsystem resource, but we want
to transform something in one of its child resources. Again, since we
are not discarding or rejecting, we get a reference to the builder for
the child resource.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">    ResourceTransformationDescriptionBuilder childBuilder =
       subsystemBuilder.addChildResource(PathElement.pathElement("some-child"));
    //We don't actually want to transform anything in /subsystem-my-subsystem/some-child=* either :-)
    //We are interested in /subsystem-my-subsystem/some-child=*/another-level
    ResourceTransformationDescriptionBuilder anotherBuilder =
       childBuilder.addChildResource(PathElement.pathElement("another-level"));
 
    //Use anotherBuilder to add child-resource and/or attribute transformation
    ....</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="attributetransformationdescriptionbuilder">AttributeTransformationDescriptionBuilder</h3>
<div class="paragraph">
<p>To transform attributes you call
<code>ResourceTransformationDescriptionBuilder.getAttributeBuilder()</code> which
returns you a <code>AttributeTransformationDescriptionBuilder</code> which is used
to define transformation for the resource&#8217;s attributes. For example this
gets the attribute builder for the subsystem resource:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">    AttributeTransformationDescriptionBuilder attributeBuilder = subSystemBuilder.getAttributeBuilder();</code></pre>
</div>
</div>
<div class="paragraph">
<p>or we could get it for one of the child resources:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">    ResourceTransformationDescriptionBuilder childBuilder =
       subsystemBuilder.addChildResource(PathElement.pathElement("some-child"));
    AttributeTransformationDescriptionBuilder attributeBuilder = childBuilder.getAttributeBuilder();</code></pre>
</div>
</div>
<div class="paragraph">
<p>The attribute transformations defined by the
<code>AttributeTransformationDescriptionBuilder</code> will also impact the
parameters to all operations defined on the resource. This means that if
you have defined the <code>example</code> attribute of
<code>/subsystem=my-subsystem/some-child=*</code> to reject transformation if its
value is <code>true</code>, the inital domain transfer will reject if it is <code>true</code>,
also the transformation of the following operations will reject:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-ruby" data-lang="ruby">    /subsystem=my-subsystem/some-child=test:add(example=true)
    /subsystem=my-subsystem:write-attribute(name=example, value=true)
    /subsystem=my-subsystem:custom-operation(example=true)</code></pre>
</div>
</div>
<div class="paragraph">
<p>The following operations will pass in this example, since the <code>example</code>
attribute is not getting set to <code>true</code></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-ruby" data-lang="ruby">    /subsystem=my-subsystem/some-child=test:add(example=false)
    /subsystem=my-subsystem/some-child=test:add()             //Here it 'example' is simply left undefined
    /subsystem=my-subsystem:write-attribute(name=example, value=false)
    /subsystem=my-subsystem:undefine-attribute(name=example)  //Again this makes 'example' undefined
    /subsystem=my-subsystem:custom-operation(example=false)</code></pre>
</div>
</div>
<div class="paragraph">
<p>For the rest of the examples in this section we assume that the
<code>attributeBuilder</code> is for <code>/subsystem=my-subsystem</code></p>
</div>
<div class="sect3">
<h4 id="attribute-transformation-lifecycle">Attribute transformation lifecycle</h4>
<div class="paragraph">
<p>There is a well defined lifecycle used for attribute transformation that
is worth explaining before jumping into specifics. Transformation is
done in the following phases, in the following order:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p><code>discard</code> - All attributes in the domain model transfer or invoked
operation that have been registered for a discard check, are checked to
see if the attribute should be discarded. If an attribute should be
discarded, it is removed from the resource&#8217;s attributes/operation&#8217;s
parameters and it does not get passed to the next phases. Once discarded
it does not get sent to the legacy slave HC.</p>
</li>
<li>
<p><code>reject</code> - All attributes that have been registered for a reject
check (and which not have been discarded) are checked to see if the
attribute should be rejected. As explained in
<a href="#rejection-in-resource-transformers">#Rejection
in resource transformers</a> and
<a href="#rejection-in-operation-transformers">#Rejection
in operation transformers</a> exactly what happens when something is
rejected varies depending on whether we are transforming a resource or
an operation, and the version of the legacy slave HC we are transforming
for. If a transformer rejects an attribute, all other reject
transformers still get invoked, and the next phases also get invoked.
This is because we don&#8217;t know in all cases what will happen if a reject
happens. Although this might sound cumbersome, in practice it actually
makes it easier to write transformers since you only need one kind
regardless of if it is a resource, an operation, and legacy slave HC
version. However, as we will see in
<a href="#common-transformation-use-cases">Common
transformation use-cases</a>, it means some extra checks are needed when
writing reject and convert transformers.</p>
</li>
<li>
<p><code>convert</code> - All attributes that have been registered for conversion
are checked to see if the attribute should be converted. If the
attribute does not exist in the original operation/resource it may be
introduced. This is useful for setting default values for the target
legacy slave HC.</p>
</li>
<li>
<p><code>rename</code> - All attributes registered for renaming are renamed.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Next, let us have a look at how to register attributes for each of these
phases.</p>
</div>
</div>
<div class="sect3">
<h4 id="discarding-attributes">Discarding attributes</h4>
<div class="paragraph">
<p>The general idea behind a discard is that we remove attributes which do
not exist in the legacy slave HC&#8217;s model. However, as hopefully
described below, we normally can&#8217;t simply discard everything, we need to
check the values first.</p>
</div>
<div class="paragraph">
<p>To discard an attribute we need an instance of
<code>org.jboss.as.controller.transform.description.DiscardAttributeChecker</code>,
and call the following method on the
<code>AttributeTransformationDescriptionBuilder</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">     DiscardAttributeChecker discardCheckerA = ....;
     attributeBuilder.setDiscard(discardCheckerA, "attr1", "attr2");</code></pre>
</div>
</div>
<div class="paragraph">
<p>As shown, you can register the <code>DiscardAttributeChecker</code> for several
attributes at once, in the above example both <code>attr1</code> and <code>attr2</code> get
checked for if they should be discarded. You can also register different
<code>DiscardAttributeChecker</code> instances for different attributes:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">     DiscardAttributeChecker discardCheckerA = ....;
     DiscardAttributeChecker discardCheckerB = ....;
     attributeBuilder.setDiscard(discardCheckerA, "attr1");
     attributeBuilder.setDiscard(discardCheckerA, "attr2");</code></pre>
</div>
</div>
<div class="paragraph">
<p>Note that you can only have one <code>DiscardAttributeChecker</code> per attribute,
so the following would cause an error (if running with assertions
enabled, otherwise <code>discardCheckerB</code> will overwrite <code>discardCheckerA</code>):</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">     DiscardAttributeChecker discardCheckerA = ....;
     DiscardAttributeChecker discardCheckerB = ....;
     attributeBuilder.setDiscard(discardCheckerA, "attr1");
     attributeBuilder.setDiscard(discardCheckerB, "attr1");</code></pre>
</div>
</div>
<div class="sect4">
<h5 id="the-discardattributechecker-interface">The DiscardAttributeChecker interface</h5>
<div class="paragraph">
<p><code>org.jboss.as.controller.transform.description.DiscardAttributeChecker</code>
contains both the <code>DiscardAttributeChecker</code> and some helper
implementations. The implementations of this interface get called for
each attribute they are registered against. The interface itself is
quite simple:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">public interface DiscardAttributeChecker {
 
    /**
     * Returns {@code true} if the attribute should be discarded if expressions are used
     *
     * @return whether to discard if expressions are used
     */
    boolean isDiscardExpressions();</code></pre>
</div>
</div>
<div class="paragraph">
<p>Return <code>true</code> here to discard the attribute if it is an expression. If
it is an expression, and this method returns <code>true</code>, the
<code>isOperationParameterDiscardable</code> and <code>isResourceAttributeDiscardable</code>
methods will not get called.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">    /**
     * Returns {@code true} if the attribute should be discarded if it is undefined
     *
     * @return whether to discard if the attribute is undefined
     */
    boolean isDiscardUndefined();</code></pre>
</div>
</div>
<div class="paragraph">
<p>Return <code>true</code> here to discard the attribute if it is <code>undefined</code>. If it
is <code>undefined</code>, and this method returns <code>true</code>, the
<code>isDiscardExpressions</code>, <code>isOperationParameterDiscardable</code> and
<code>isResourceAttributeDiscardable</code> methods will not get called.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">    /**
     * Gets whether the given operation parameter can be discarded
     *
     * @param address the address of the operation
     * @param attributeName the name of the operation parameter.
     * @param attributeValue the value of the operation parameter.
     * @param operation the operation executed. This is unmodifiable.
     * @param context the context of the transformation
     *
     * @return {@code true} if the operation parameter value should be discarded, {@code false} otherwise.
     */
    boolean isOperationParameterDiscardable(PathAddress address, String attributeName, ModelNode attributeValue, ModelNode operation, TransformationContext context);</code></pre>
</div>
</div>
<div class="paragraph">
<p>If we are transforming an operation, this method gets called for each
operation parameter. We have access to the address of the operation, the
name and value of the operation parameter, an unmodifiable copy of the
original operation and the <code>TransformationContext</code>. The
<code>TransformationContext</code> allows you access to the original resource the
operation is working on before any transformation happened, which is
useful if you want to check other values in the resource if this is, say
a <code>write-attribute</code> operation. Return <code>true</code> to discard the operation.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">    /**
     * Gets whether the given attribute can be discarded
     *
     * @param address the address of the resource
     * @param attributeName the name of the attribute
     * @param attributeValue the value of the attribute
     * @param context the context of the transformation
     *
     * @return {@code true} if the attribute value should be discarded, {@code false} otherwise.
     */
    boolean isResourceAttributeDiscardable(PathAddress address, String attributeName, ModelNode attributeValue, TransformationContext context);</code></pre>
</div>
</div>
<div class="paragraph">
<p>If we are transforming a resource, this method gets called for each
attribute in the resource. We have access to the address of the
resource, the name and value of the attribute, and the
<code>TransformationContext</code>. Return <code>true</code> to discard the operation.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="discardattributechecker-helper-classesimplementations">DiscardAttributeChecker helper classes/implementations</h5>
<div class="paragraph">
<p><code>DiscardAttributeChecker</code> contains a few helper implementations for the
most common cases to save you writing the same stuff again and again.</p>
</div>
<div class="sect5">
<h6 id="discardattributechecker.defaultdiscardattributechecker">DiscardAttributeChecker.DefaultDiscardAttributeChecker</h6>
<div class="paragraph">
<p><code>DiscardAttributeChecker.DefaultDiscardAttributeChecker</code> is an abstract
convenience class. In most cases you don&#8217;t need a separate check for if
an operation or a resource is being transformed, so it makes both the
<code>isResourceAttributeDiscardable()</code> and
<code>isOperationParameterDiscardable()</code> methods call the following method.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">protected abstract boolean isValueDiscardable(PathAddress address, String attributeName, ModelNode attributeValue, TransformationContext context);</code></pre>
</div>
</div>
<div class="paragraph">
<p>All you lose, in the case of an operation transformation, is the name of
the transformed operation. The constructor of
<code>DiscardAttributeChecker.DefaultDiscardAttributeChecker</code> also allows you
to define values for <code>isDiscardExpressions()</code> and
<code>isDiscardUndefined()</code>.</p>
</div>
</div>
<div class="sect5">
<h6 id="discardattributechecker.discardattributevaluechecker">DiscardAttributeChecker.DiscardAttributeValueChecker</h6>
<div class="paragraph">
<p>This is another convenience class, which allows you to discard an
attribute if it has one or more values. Here is a real-world example
from the <code>jpa</code> subsystem:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">    private void initializeTransformers_1_1_0(SubsystemRegistration subsystemRegistration) {
        ResourceTransformationDescriptionBuilder builder = TransformationDescriptionBuilder.Factory.createSubsystemInstance();
        builder.getAttributeBuilder()
            .setDiscard(
                   new DiscardAttributeChecker.DiscardAttributeValueChecker(new ModelNode(ExtendedPersistenceInheritance.DEEP.toString())),
                   JPADefinition.DEFAULT_EXTENDEDPERSISTENCE_INHERITANCE)
            .addRejectCheck(RejectAttributeChecker.DEFINED, JPADefinition.DEFAULT_EXTENDEDPERSISTENCE_INHERITANCE)
            .end();
        TransformationDescription.Tools.register(builder.build(), subsystemRegistration, ModelVersion.create(1, 1, 0));
    }</code></pre>
</div>
</div>
<div class="paragraph">
<p>We will come back to the reject checks in the
<a href="#rejecting-attributes">#Rejecting
attributes</a> section. We are saying that we should discard the
<code>JPADefinition.DEFAULT_EXTENDEDPERSISTENCE_INHERITANCE</code> attribute if it
has the value <code>deep</code>. The reasoning here is that this attribute did not
exist in the old model, but the legacy slave HCs <em>implied behaviour</em> is
that this was <code>deep</code>. In the current version we added the possibility to
toggle this setting, but only <code>deep</code> is consistent with what is
available in the legacy slave HC. In this case we are using the
constructor for <code>DiscardAttributeChecker.DiscardAttributeValueChecker</code>
which says don&#8217;t discard if it uses expressions, and discard if it is
<code>undefined</code>. If it is <code>undefined</code> in the current model, looking at the
default value of
<code>JPADefinition.DEFAULT_EXTENDEDPERSISTENCE_INHERITANCE</code>, it is <code>deep</code>,
so a discard is in line with the implied legacy behaviour. If an
expression is used, we cannot discard since we have no idea what the
expression will resolve to on the slave HC.</p>
</div>
</div>
<div class="sect5">
<h6 id="discardattributechecker.always">DiscardAttributeChecker.ALWAYS</h6>
<div class="paragraph">
<p><code>DiscardAttributeChecker.ALWAYS</code> will always discard an attribute. Use
this sparingly, since normally the presence of an attribute in the
current model implies some behaviour should be turned on, and if that
does not exist in the legacy model it implies that that behaviour does
not exist in the legacy slave HC and its servers. Normally the legacy
slave HC&#8217;s subsystem has some implied behaviour which is better checked
for by using a <code>DiscardAttributeChecker.DiscardAttributeValueChecker</code>.
One valid use for <code>DiscardAttributeChecker.ALWAYS</code> can be found in the
<code>ejb3</code> subsystem:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">    private static void registerTransformers_1_1_0(SubsystemRegistration subsystemRegistration) {
        ResourceTransformationDescriptionBuilder builder = TransformationDescriptionBuilder.Factory.createSubsystemInstance()
                .getAttributeBuilder()
                 ...
                // We can always discard this attribute, because it's meaningless without the security-manager subsystem, and
                // a legacy slave can't have that subsystem in its profile.
                .setDiscard(DiscardAttributeChecker.ALWAYS, EJB3SubsystemRootResourceDefinition.DISABLE_DEFAULT_EJB_PERMISSIONS)
   ...</code></pre>
</div>
</div>
<div class="paragraph">
<p>As the comment says, this attribute only makes sense with the
security-manager susbsystem, which does not exist on legacy slaves
running ModelVersion 1.1.0 of the <code>ejb3</code> subsystem.</p>
</div>
</div>
<div class="sect5">
<h6 id="discardattributechecker.undefined">DiscardAttributeChecker.UNDEFINED</h6>
<div class="paragraph">
<p><code>DiscardAttributeChecker.UNDEFINED</code> will discard an attribute if it is
<code>undefined</code>. This is normally safer than
<code>DiscardAttributeChecker.ALWAYS</code> since the attribute is not set in the
current model, we don&#8217;t need to send it to the legacy model. However,
you should check that this attribute not existing in the legacy slave
HC, implies the same functionality as being undefined in the current DC.</p>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="rejecting-attributes">Rejecting attributes</h4>
<div class="paragraph">
<p>The next step is to check attributes and values which we know for sure
will not work on the target legacy slave HC.</p>
</div>
<div class="paragraph">
<p>To reject an attribute we need an instance of
<code>org.jboss.as.controller.transform.description.RejectAttributeChecker</code>,
and call the following method on the
<code>AttributeTransformationDescriptionBuilder</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">     RejectAttributeChecker rejectCheckerA = ....;
     attributeBuilder.addRejectCheck(rejectCheckerA, "attr1", "attr2");</code></pre>
</div>
</div>
<div class="paragraph">
<p>As shown you can register the <code>RejectAttributeChecker</code> for several
attributes at once, in the above example both <code>attr1</code> and <code>attr2</code> get
checked for if they should be discarded. You can also register different
<code>RejectAttributeChecker</code> instances for different attributes:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">     RejectAttributeChecker rejectCheckerA = ....;
     RejectAttributeChecker rejectCheckerB = ....;
     attributeBuilder.addRejectCheck(rejectCheckerA, "attr1");
     attributeBuilder.addRejectCheck(rejectCheckerB, "attr2");</code></pre>
</div>
</div>
<div class="paragraph">
<p>You can also register several <code>RejectAttributeChecker</code> instances per
attribute</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">     RejectAttributeChecker rejectCheckerA = ....;
     RejectAttributeChecker rejectCheckerB = ....;
     attributeBuilder.addRejectCheck(rejectCheckerA, "attr1");
     attributeBuilder.addRejectCheck(rejectCheckerB, "attr1, "attr2");</code></pre>
</div>
</div>
<div class="paragraph">
<p>In this case <code>attr1</code> gets both <code>rejectCheckerA</code> and <code>rejectCheckerB</code>.
For attributes with several <code>RejectAttributeChecker</code> registered, they
get processed in the order that they have been added. So when checking
<code>attr1</code> for rejection, <code>rejectCheckerA</code> gets run before
<code>rejectCheckerB</code>. As mentioned in
<a href="#attribute-transformation-lifecycle">#Attribute
transformation lifecycle</a>, if an attribute is rejected, we still invoke
the rest of the reject checkers.</p>
</div>
<div class="sect4">
<h5 id="the-rejectattributechecker-interface">The RejectAttributeChecker interface</h5>
<div class="paragraph">
<p><code>org.jboss.as.controller.transform.description.RejectAttributeChecker</code>
contains both the <code>RejectAttributeChecker</code> and some helper
implementations. The implementations of this interface get called for
each attribute they are registered against. The interface itself is
quite simple, and its main methods are similar to
<code>DiscardAttributeChecker</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">public interface RejectAttributeChecker {
    /**
     * Determines whether the given operation parameter value is not understandable by the target process and needs
     * to be rejected.
     *
     * @param address        the address of the operation
     * @param attributeName  the name of the attribute
     * @param attributeValue the value of the attribute
     * @param operation      the operation executed. This is unmodifiable.
     * @param context        the context of the transformation
     * @return {@code true} if the parameter value is not understandable by the target process and so needs to be rejected, {@code false} otherwise.
     */
    boolean rejectOperationParameter(PathAddress address, String attributeName, ModelNode attributeValue, ModelNode operation, TransformationContext context);</code></pre>
</div>
</div>
<div class="paragraph">
<p>If we are transforming an operation, this method gets called for each
operation parameter. We have access to the address of the operation, the
name and value of the operation parameter, an unmodifiable copy of the
original operation and the <code>TransformationContext</code>. The
<code>TransformationContext</code> allows you access to the original resource the
operation is working on before any transformation happened, which is
useful if you want to check other values in the resource if this is, say
a <code>write-attribute</code> operation. Return <code>true</code> to reject the operation.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">    /**
     * Gets whether the given resource attribute value is not understandable by the target process and needs
     * to be rejected.
     *
     * @param address        the address of the resource
     * @param attributeName  the name of the attribute
     * @param attributeValue the value of the attribute
     * @param context        the context of the transformation
     * @return {@code true} if the attribute value is not understandable by the target process and so needs to be rejected, {@code false} otherwise.
     */
    boolean rejectResourceAttribute(PathAddress address, String attributeName, ModelNode attributeValue, TransformationContext context);</code></pre>
</div>
</div>
<div class="paragraph">
<p>If we are transforming a resource, this method gets called for each
attribute in the resource. We have access to the address of the
resource, the name and value of the attribute, and the
<code>TransformationContext</code>. Return <code>true</code> to discard the operation.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">    /**
     * Returns the log message id used by this checker. This is used to group it so that all attributes failing a type of rejection
     * end up in the same error message
     *
     * @return the log message id
     */
    String getRejectionLogMessageId();</code></pre>
</div>
</div>
<div class="paragraph">
<p>Here we need a unique id for the log message from the
<code>RejectAttributeChecker</code>. It is used to group rejected attributes by
their log message. A typical implementation will contain \{\{return
getRejectionLogMessage(Collections.&lt;String, ModelNode&gt;emptyMap());}</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">    /**
     * Gets the log message if the attribute failed rejection
     *
     * @param attributes a map of all attributes failed in this checker and their values
     * @return the formatted log message
     */
    String getRejectionLogMessage(Map&lt;String, ModelNode&gt; attributes);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Here we return a message saying why the attributes were rejected, with
the possibility to format the message to include the names of all the
rejected attributes and the values they had.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="rejectattributechecker-helper-classesimplementations">RejectAttributeChecker helper classes/implementations</h5>
<div class="paragraph">
<p><code>RejectAttributeChecker</code> contains a few helper classes for the most
common scenarios to save you from writing the same stuff again and
again.</p>
</div>
<div class="sect5">
<h6 id="rejectattributechecker.defaultrejectattributechecker">RejectAttributeChecker.DefaultRejectAttributeChecker</h6>
<div class="paragraph">
<p><code>RejectAttributeChecker.DefaultRejectAttributeChecker</code> is an abstract
convenience class. In most cases you don&#8217;t need a separate check for if
an operation or a resource is being transformed, so it makes both the
<code>rejectOperationParameter()</code> and <code>rejectResourceAttribute()</code> methods
call the following method.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">protected abstract boolean rejectAttribute(PathAddress address, String attributeName, ModelNode attributeValue, TransformationContext context);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Like <code>DefaultDiscardAttributeChecker</code>, all you loose is the name of the
transformed operation, in the case of operation transformation.</p>
</div>
</div>
<div class="sect5">
<h6 id="rejectattributechecker.defined">RejectAttributeChecker.DEFINED</h6>
<div class="paragraph">
<p><code>RejectAttributeChecker.DEFINED</code> is used to reject any attribute that
has a defined value. Normally this is because the attribute does not
exist on the target legacy slave HC. A typical use case for these is for
the <em>implied behavior</em> example we looked at in the <code>jpa</code> subsystem in
<a href="#discardattributechecker.discardattributevaluechecker">#DiscardAttributeChecker.DiscardAttributeValueChecker</a></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">    private void initializeTransformers_1_1_0(SubsystemRegistration subsystemRegistration) {
        ResourceTransformationDescriptionBuilder builder = TransformationDescriptionBuilder.Factory.createSubsystemInstance();
        builder.getAttributeBuilder()
            .setDiscard(
                   new DiscardAttributeChecker.DiscardAttributeValueChecker(new ModelNode(ExtendedPersistenceInheritance.DEEP.toString())),
                   JPADefinition.DEFAULT_EXTENDEDPERSISTENCE_INHERITANCE)
            .addRejectCheck(RejectAttributeChecker.DEFINED, JPADefinition.DEFAULT_EXTENDEDPERSISTENCE_INHERITANCE)
            .end();
        TransformationDescription.Tools.register(builder.build(), subsystemRegistration, ModelVersion.create(1, 1, 0));
    }</code></pre>
</div>
</div>
<div class="paragraph">
<p>So we discard the
<code>JPADefinition.DEFAULT_EXTENDEDPERSISTENCE_INHERITANCE</code> value if it is
not an expression, and also has the value <code>deep</code>. Now if it was not
discarded, it would will still be defined so we reject it.</p>
</div>
<div class="paragraph">
<p>Important</p>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<div class="title">Important</div>
</td>
<td class="content">
Reject and discard often work in pairs.
</td>
</tr>
</table>
</div>
</div>
<div class="sect5">
<h6 id="rejectattributechecker.simple_expressions">RejectAttributeChecker.SIMPLE_EXPRESSIONS</h6>
<div class="paragraph">
<p><code>RejectAttributeChecker.SIMPLE_EXPRESSIONS</code> can be used to reject an
attribute that contains expressions. This was used a lot for
transformations to subsystems in JBoss AS 7.1.x, since we had not fully
realized the importance of where to support expressions until JBoss AS
7.2.0 was released, so a lot of attributes in earlier versions were
missing expressions support.</p>
</div>
</div>
<div class="sect5">
<h6 id="rejectattributechecker.listrejectattributechecker">RejectAttributeChecker.ListRejectAttributeChecker</h6>
<div class="paragraph">
<p>The
<code>RejectAttributeChecker}}s we have seen so far work on simple attributes, i.e. where the attribute has a ModelType which is one of the primitives. We also have a {{RejectAttributeChecker.ListRejectAttributeChecker</code>
which allows you to define a checker for the elements of a list, when
the type of an attribute is <code>ModelType.LIST</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">    attributeBuilder
            .addRejectCheck(new ListRejectAttributeChecker(RejectAttributeChecker.EXPRESSIONS), "attr1");</code></pre>
</div>
</div>
<div class="paragraph">
<p>For <code>attr1</code> it will check each element of the list and run
<code>RejectAttributeChecker.EXPRESSIONS</code> to check that each element is not
an expression. You can of course pass in another kind of
<code>RejectAttributeChecker</code> to check the elements as well.</p>
</div>
</div>
<div class="sect5">
<h6 id="rejectattributechecker.objectfieldsrejectattributechecker">RejectAttributeChecker.ObjectFieldsRejectAttributeChecker</h6>
<div class="paragraph">
<p>For attributes where the type is <code>ModelType.OBJECT</code> we have
<code>RejectAttributeChecker.ObjectFieldsRejectAttributeChecker</code> which allows
you to register different reject checkers for the different fields of
the registered object.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">    Map&lt;String, RejectAttributeChecker&gt; fieldRejectCheckers = new HashMap&lt;String, RejectAttributeChecker&gt;();
    fieldRejectCheckers.put("time", RejectAttributeChecker.SIMPLE_EXPRESSIONS);
    fieldRejectCheckers.put("unit", "Lunar Month");
    attributeBuilder
            .addRejectCheck(new ObjectFieldsRejectAttributeChecker(fieldRejectCheckers), "attr1");</code></pre>
</div>
</div>
<div class="paragraph">
<p>Now if <code>attr1</code> is a complex type where
<code>attr1.get("time").getType() == ModelType.EXPRESSION</code> or
<code>attr1.get("unit").asString().equals("Lunar Month")</code> we reject the
attribute.</p>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="converting-attributes">Converting attributes</h4>
<div class="paragraph">
<p>To convert an attribute you register an
<code>org.jboss.as.controller.transform.description.AttributeConverter</code>
instance against the attributes you want to convert:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">    AttributeConverter converterA = ...;
    AttributeConverter converterB = ...;
    attributeBuilder
            .setValueConverter(converterA, "attr1", "attr2");
    attributeBuilder
            .setValueConverter(converterB, "attr3");</code></pre>
</div>
</div>
<div class="paragraph">
<p>Now if <code>attr1</code> and <code>attr2</code> get converted with <code>converterA</code>, while
<code>attr3</code> gets converted with <code>converterB</code>.</p>
</div>
<div class="sect4">
<h5 id="the-attributeconverter-interface">The AttributeConverter interface</h5>
<div class="paragraph">
<p>The <code>AttributeConverter</code> interface gets called for each attribute for
which the <code>AttributeConverter</code> has been registered</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">public interface AttributeConverter {
 
    /**
     * Converts an operation parameter
     *
     * @param address the address of the operation
     * @param attributeName the name of the operation parameter
     * @param attributeValue the value of the operation parameter to be converted
     * @param operation the operation executed. This is unmodifiable.
     * @param context the context of the transformation
     */
    void convertOperationParameter(PathAddress address, String attributeName, ModelNode attributeValue, ModelNode operation, TransformationContext context);</code></pre>
</div>
</div>
<div class="paragraph">
<p>If we are transforming an operation, this method gets called for each
operation parameter for which the con. We have access to the address of
the operation, the name and value of the operation parameter, an
unmodifiable copy of the original operation and the
<code>TransformationContext</code>. The <code>TransformationContext</code> allows you access
to the original resource the operation is working on before any
transformation happened, which is useful if you want to check other
values in the resource if this is, say a write-attribute operation. To
change the attribute value, you modify the <code>attributeValue</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">    /**
     * Converts a resource attribute
     *
     * @param address the address of the operation
     * @param attributeName the name of the attribute
     * @param attributeValue the value of the attribute to be converted
     * @param context the context of the transformation
     */
    void convertResourceAttribute(PathAddress address, String attributeName, ModelNode attributeValue, TransformationContext context);</code></pre>
</div>
</div>
<div class="paragraph">
<p>If we are transforming a resource, this method gets called for each
attribute in the resource. We have access to the address of the
resource, the name and value of the attribute, and the
<code>TransformationContext</code>. To change the attribute value, you modify the
<code>attributeValue</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">}</code></pre>
</div>
</div>
<div class="paragraph">
<p>A hypothetical example is if the current and legacy subsystems both
contain an attribute called <code>timeout</code>. In the legacy model this was
specified to be milliseconds, however in the current model it has been
changed to be seconds, hence we need to convert the value when sending
it to slave HCs using the legacy model:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">     AttributeConverter secondsToMs = new AttributeConverter.DefaultAttributeConverter() {
                  @Override
                  protected void convertAttribute(PathAddress address, String attributeName, ModelNode attributeValue,
                           TransformationContext context) {
                      if (attributeValue.isDefined()) {
                           int seconds = attributeValue.asInt();
                           int milliseconds = seconds * 1000;
                           attributeValue.set(milliseconds);
                      }
                  }
          };
 
     attributeBuilder.
          .setValueConverter(secondsToMs , "timeout")</code></pre>
</div>
</div>
<div class="paragraph">
<p>We need to be a bit careful here. If the <code>timeout</code> attribute is an
expression our nice conversion will not work, so we need to add a reject
check to make sure it is not an expression as well:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">     attributeBuilder.
          .addRejectCheck(SIMPLE_EXPRESSIONS, "timeout")
          .setValueConverter(secondsToMs , "timeout")</code></pre>
</div>
</div>
<div class="paragraph">
<p>Now it should be fine.</p>
</div>
<div class="paragraph">
<p><code>AttributeConverter.DefaultAttributeConverter</code> is is an abstract
convenience class. In most cases you don&#8217;t need a separate check for if
an operation or a resource is being transformed, so it makes both the
convertOperationParameter() and convertResourceAttribute() methods call
the following method.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">protected abstract void convertAttribute(PathAddress address, String attributeName, ModelNode attributeValue, TransformationContext context);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Like <code>DefaultDiscardAttributeChecker</code> and
<code>DefaultRejectAttributeChecker</code>, all you loose is the name of the
transformed operation, in the case of operation transformation.</p>
</div>
<div class="sect5">
<h6 id="introducing-attributes-during-transformation">Introducing attributes during transformation</h6>
<div class="paragraph">
<p>Say both the current and the legacy models have an attribute called
<code>port</code>. In the legacy version this attribute had to be specified, and
the default xml configuration had <code>1234</code> for its value. In the current
version this attribute has been made optional with a default value of
<code>1234</code> so that it does not need to be specified. When transforming to a
slave HC using the old version we will need to introduce this attribute
if the new model does not contain it:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">     attributeBuilder.
         setValueConverter(AttributeConverter.Factory.createHardCoded(new ModelNode(1234) true), "port");</code></pre>
</div>
</div>
<div class="paragraph">
<p>So what this factory method does is to create an implementation of
<code>AttributeConverter.DefaultAttributeConverter</code> where in
<code>convertAttribute()</code> we set <code>attributeValue</code> to have the value <code>1234</code> if
it is <code>undefined</code>. As long as <code>attributeValue</code> gets set in that method
it will get set in the model, regardless of if it existed already or
not.</p>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="renaming-attributes">Renaming attributes</h4>
<div class="paragraph">
<p>To rename an attribute, you simply do</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">    attributeBuilder.addRename("my-name", "legacy-name");</code></pre>
</div>
</div>
<div class="paragraph">
<p>Now, in the initial domain transfer to the legacy slave HC, we rename
<code>/subsystem=my-subsystem&#8217;s `my-name</code> attribute to <code>legacy-name</code>. Also,
the operations involving this attribute are affected, so</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-ruby" data-lang="ruby">    /subsystem=my-subsystem/:add(my-name=true)  -&gt;
         /subsystem=my-subsystem/:add(legacy-name=true)
    /subsystem=my-subsystem:write-attribute(name=my-name, value=true) -&gt;
         /subsystem=my-subsystem:write-attribute(name=legacy-name, value=true)
    /subsystem=my-subsystem:undefine-attribute(name=my-name) -&gt;
         /subsystem=my-subsystem:undefine-attribute(name=legacy-name)</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="operationtransformationoverridebuilder">OperationTransformationOverrideBuilder</h3>
<div class="paragraph">
<p>All operations on a resource automatically get the same transformations
on their parameters as set up by the
<code>AttributeTransformationDescriptionBuilder</code>. In some cases you might
want to change this, so you can use the
<code>OperationTransformationOverrideBuilder</code>, which is got from:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">OperationTransformationOverrideBuilder operationBuilder = subSystemBuilder.addOperationTransformationOverride("some-operation");</code></pre>
</div>
</div>
<div class="paragraph">
<p>In this case the operation will now no longer inherit the
attribute/operation parameter transformations, so they are effectively
turned off. In other cases you might want to include them by calling
<code>inheritResourceAttributeDefinitions()</code>, and to include some more checks
(the <code>OperationTransformationBuilder</code> interface has all the methods
found in <code>AttributeTransformationBuilder</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">    OperationTransformationOverrideBuilder operationBuilder = subSystemBuilder.addOperationTransformationOverride("some-operation");
    operationBuilder.inheritResourceAttributeDefinitions();
    operationBuilder.setValueConverter(AttributeConverter.Factory.createHardCoded(new ModelNode(1234) true), "port");</code></pre>
</div>
</div>
<div class="paragraph">
<p>You can also rename operations, in this case the operation
<code>some-operation</code> gets renamed to <code>legacy-operation</code> before getting sent
to the legacy slave HC.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">    OperationTransformationOverrideBuilder operationBuilder = subSystemBuilder.addOperationTransformationOverride("some-operation");
    operationBuilder.rename("legacy-operation");</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="evolving-transformers-with-subsystem-modelversions">Evolving transformers with subsystem ModelVersions</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Say you have a subsystem with ModelVersions 1.0.0 and 1.1.0. There will
(hopefully!) already be transformers in place for 1.1.0 to 1.0.0
transformations. Let&#8217;s say that the transformers registration looks
like:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">public class SomeExtension implements Extension {
 
    private static final String SUBSYSTEM_NAME = "my-subsystem"'
 
    private static final int MANAGEMENT_API_MAJOR_VERSION = 1;
    private static final int MANAGEMENT_API_MINOR_VERSION = 1;
    private static final int MANAGEMENT_API_MICRO_VERSION = 0;
 
    @Override
    public void initialize(ExtensionContext context) {
        SubsystemRegistration registration = context.registerSubsystem(SUBSYSTEM_NAME, MANAGEMENT_API_MAJOR_VERSION,
                MANAGEMENT_API_MINOR_VERSION, MANAGEMENT_API_MICRO_VERSION);
        //Register the resource definitions
        ....
    }
 
    private void registerTransformers(final SubsystemRegistration subsystem) {
        registerTransformers_1_0_0(subsystem);
    }
 
    /**
     * Registers transformers from the current version to ModelVersion 1.0.0
     */
    private void registerTransformers_1_0_0(SubsystemRegistration subsystem) {
        ResourceTransformationDescriptionBuilder builder = TransformationDescriptionBuilder.Factory.createSubsystemInstance();
        builder.getAttributeBuilder()
            .addRejectCheck(RejectAttributeChecker.DEFINED, "attr1")
            .end();
        TransformationDescription.Tools.register(builder.build(), subsystem, ModelVersion.create(1, 0, 0));
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Now say we want to do a new version of the model. This new version
contains a new attribute called 'new-attr' which cannot be defined when
transforming to 1.1.0, we bump the model version to 2.0.0:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">public class SomeExtension implements Extension {
 
    private static final String SUBSYSTEM_NAME = "my-subsystem"'
 
    private static final int MANAGEMENT_API_MAJOR_VERSION = 2;
    private static final int MANAGEMENT_API_MINOR_VERSION = 0;
    private static final int MANAGEMENT_API_MICRO_VERSION = 0;
 
    @Override
    public void initialize(ExtensionContext context) {
        SubsystemRegistration registration = context.registerSubsystem(SUBSYSTEM_NAME, MANAGEMENT_API_MAJOR_VERSION,
                MANAGEMENT_API_MINOR_VERSION, MANAGEMENT_API_MICRO_VERSION);
        //Register the resource definitions
        ....
    }</code></pre>
</div>
</div>
<div class="paragraph">
<p>There are a few ways to evolve your transformers:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="#the-old-way">#The old
way</a></p>
</li>
<li>
<p><a href="#chained-transformers">#Chained
transformers</a></p>
</li>
</ul>
</div>
<div class="sect2">
<h3 id="the-old-way">The old way</h3>
<div class="paragraph">
<p>This is the way that has been used up to WildFly {wildflyVersion}.x. However, in
WildFly 9 and later, it is strongly recommended to migrate to what is
mentioned in
<a href="#chained-transformers">#Chained
transformers</a></p>
</div>
<div class="paragraph">
<p>Now we need some new transformers from the current ModelVersion to 1.1.0
where we reject any defined occurrances of our new attribute <code>new-attr</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">    private void registerTransformers(final SubsystemRegistration subsystem) {
        registerTransformers_1_0_0(subsystem);
        registerTransformers_1_1_0(subsystem);
    }
 
    /**
     * Registers transformers from the current version to ModelVersion 1.1.0
     */
    private void registerTransformers_1_1_0(SubsystemRegistration subsystem) {
        ResourceTransformationDescriptionBuilder builder = TransformationDescriptionBuilder.Factory.createSubsystemInstance();
        builder.getAttributeBuilder()
            .addRejectCheck(RejectAttributeChecker.DEFINED, "new-attr")
            .end();
        TransformationDescription.Tools.register(builder.build(), subsystem, ModelVersion.create(1, 1, 0));
    }</code></pre>
</div>
</div>
<div class="paragraph">
<p>So that is all well and good, however we also need to take into account
that <code>new-attr</code> <strong>does not exist in ModelVersion 1.0.0 either</strong>, so we
need to extend our transformer for 1.0.0 to reject it there as well. As
you can see 1.0.0 also rejects a defined 'attr1' in addition to the
'new-attr'(which is rejected in both versions).</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">    /**
     * Registers transformers from the current version to ModelVersion 1.0.0
     */
    private void registerTransformers_1_0_0(SubsystemRegistration subsystem) {
        ResourceTransformationDescriptionBuilder builder = TransformationDescriptionBuilder.Factory.createSubsystemInstance();
        builder.getAttributeBuilder()
            .addRejectCheck(RejectAttributeChecker.DEFINED, "attr1", "new-attr")
            .end();
        TransformationDescription.Tools.register(builder.build(), subsystem, ModelVersion.create(1, 0, 0));
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Now <code>new-attr</code> will be rejected if defined for all previous model
versions.</p>
</div>
</div>
<div class="sect2">
<h3 id="chained-transformers">Chained transformers</h3>
<div class="paragraph">
<p>Since 'The old way' had a lot of duplication of code, since WildFly 9 we
now have chained transformers. You obtain a
<code>ChainedTransformationDescriptionBuilder</code> which is a different entry
point to the <code>ResourceTransformationDescriptionBuilder</code> we have seen
earlier. Each <code>ResourceTransformationDescriptionBuilder</code> deals with
transformation across one version delta.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">    private void registerTransformers(SubsystemRegistration subsystem) {
        ModelVersion version1_1_0 = ModelVersion.create(1, 1, 0);
        ModelVersion version1_0_0 = ModelVersion.create(1, 0, 0);
 
        ChainedTransformationDescriptionBuilder chainedBuilder =
              TransformationDescriptionBuilder.Factory.createChainedSubystemInstance(subsystem.getSubsystemVersion());
 
        //Differences between the current version and 1.1.0
        ResourceTransformationDescriptionBuilder builder110 =
            chainedBuilder.create(subsystem.getSubsystemVersion(), version1_1_0);
        builder110.getAttributeBuilder()
            .addRejectCheck(RejectAttributeChecker.DEFINED, "new-attr")
            .end();
 
        //Differences between the 1.1.0 and 1.0.0
        ResourceTransformationDescriptionBuilder builder100 =
            chainedBuilder.create(subsystem.getSubsystemVersion(), version1_0_0);
        builder110.getAttributeBuilder()
            .addRejectCheck(RejectAttributeChecker.DEFINED, "attr1")
            .end();
 
        chainedBuilder.buildAndRegister(subsystem, new ModelVersion[]{version1_0_0, version1_1_0});</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>buildAndRegister(ModelVersion[]&#8230;&#8203; chains)</code> method registers a
chain consisting of the built <code>builder110</code> and <code>builder100</code> for
transformation to 1.0.0, and a chain consisting of the built
<code>builder110</code> for transformation to 1.1.0. It allows you to specify more
than one chain.</p>
</div>
<div class="paragraph">
<p>Now when transforming from the current version to 1.0.0, the resource is
first transformed from the current version to 1.1.0 (which rejects a
defined <code>new-attr</code>) and then it is transformed from 1.1.0 to 1.0.0
(which rejects a defined <code>attr1</code>). So when evolving transformers you
should normally only need to add things to the last version delta. The
full current-to-1.1.0 transformation is run before the 1.1.0-to-1.0.0
transformation is run.</p>
</div>
<div class="paragraph">
<p>One thing worth pointing out that the value returned by
<code>TransformationContext.readResource(PathAddress address)</code> and
<code>TransformationContext.readResourceFromRoot(PathAddress address)</code> which
you can use from your custom <code>RejectAttributeChecker</code>,
<code>DiscardAttributeChecker</code> and <code>AttributeConverter</code> behaves slightly
differently depending on if you are transforming an operation or a
resource.</p>
</div>
<div class="paragraph">
<p>During <em>resource transformation</em> this will be the latest model, so in
our above example, in the current-to-1.1.0 transformation it will be the
original model. In the 1.1.0-to-1.0.0 transformation, it will be the
result of the current-to-1.1.0 transformation.</p>
</div>
<div class="paragraph">
<p>During <em>operation transformation</em> these methods will always return the
original model (we are transforming operations, not resources!).</p>
</div>
<div class="paragraph">
<p>In WildFly 9 we are now less aggressive about transforming to all
previous versions of WildFly, however we still have a lot of good tests
for running against 7.1.x, 8. Also, for Red Hat employees we have tests
against EAP versions. These tests no longer get run by default, to run
them you need to specify some system properties when invoking maven.
They are:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>-Djboss.test.transformers.subsystem.old</code> - enables the non-default
subsystem tests.</p>
</li>
<li>
<p>-Djboss.test.transformers.eap - (Red Hat developers only), enables the
eap tests, but only the ones run by default. If run in conjunction with
<code>-Djboss.test.transformers.subsystem.old</code> you get all the possible
subsystem tests run.</p>
</li>
<li>
<p>-Djboss.test.transformers.core.old - enables the non-default core
model tests.</p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="testing-transformers">Testing transformers</h2>
<div class="sectionbody">
<div class="paragraph">
<p>To test transformation you need to extend
<code>org.jboss.as.subsystem.test.AbstractSubsystemTest</code> or
<code>org.jboss.as.subsystem.test.AbstractSubsystemBaseTest</code>. Then, in order
to have the best test coverage possible, you should test the fullest
configuration that will work, and you should also test configurations
that don&#8217;t work if you have rejecting transformers registered. The
following example is from the threads subsystem, and I have only
included the tests against 7.1.2 - there are more! First we need to set
up our test:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">public class ThreadsSubsystemTestCase extends AbstractSubsystemBaseTest {
    public ThreadsSubsystemTestCase() {
        super(ThreadsExtension.SUBSYSTEM_NAME, new ThreadsExtension());
    }
 
    @Override
    protected String getSubsystemXml() throws IOException {
        return readResource("threads-subsystem-1_1.xml");
    }</code></pre>
</div>
</div>
<div class="paragraph">
<p>So we say that this test is for the <code>threads</code> subsystem, and that it is
implemented by <code>ThreadsExtension</code>. This is the same test framework as we
use in
<a href="Example_subsystem.html#src-557103_Examplesubsystem-Testingtheparsers">Example
subsystem#Testing the parsers</a>, but we will only talk about the parts
relevant to transformers here.</p>
</div>
<div class="sect2">
<h3 id="testing-a-configuration-that-works">Testing a configuration that works</h3>
<div class="paragraph">
<p>To test a configuration xxx</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">    @Test
    public void testTransformerAS712() throws Exception {
        testTransformer_1_0(ModelTestControllerVersion.V7_1_2_FINAL);
    }
    /**
     * Tests transformation of model from 1.1.0 version into 1.0.0 version.
     *
     * @throws Exception
     */
    private void testTransformer_1_0(ModelTestControllerVersion controllerVersion) throws Exception {
        String subsystemXml = "threads-transform-1_0.xml";   //This has no expressions not understood by 1.0
        ModelVersion modelVersion = ModelVersion.create(1, 0, 0); //The old model version
        //Use the non-runtime version of the extension which will happen on the HC
        KernelServicesBuilder builder = createKernelServicesBuilder(AdditionalInitialization.MANAGEMENT)
                .setSubsystemXmlResource(subsystemXml);
 
        final PathAddress subsystemAddress = PathAddress.pathAddress(PathElement.pathElement(SUBSYSTEM, mainSubsystemName));
 
        // Add legacy subsystems
        builder.createLegacyKernelServicesBuilder(null, controllerVersion, modelVersion)
                .addOperationValidationResolve("add", subsystemAddress.append(PathElement.pathElement("thread-factory")))
                .addMavenResourceURL("org.jboss.as:jboss-as-threads:" + controllerVersion.getMavenGavVersion())
                .excludeFromParent(SingleClassFilter.createFilter(ThreadsLogger.class));
 
        KernelServices mainServices = builder.build();
        KernelServices legacyServices = mainServices.getLegacyServices(modelVersion);
        Assert.assertNotNull(legacyServices);
        checkSubsystemModelTransformation(mainServices, modelVersion);
    }</code></pre>
</div>
</div>
<div class="paragraph">
<p>What this test does is get the builder to configure the test controller
using <code>threads-transform-1_0.xml</code>. This main builder works with the
current subsystem version, and the jars in the WildFly checkout.</p>
</div>
<div class="paragraph">
<p>Next we configure a 'legacy' controller. This will run the version of
the core libraries (e.g the <code>controller</code> module) as found in the
targeted legacy version of JBoss AS/Wildfly), and the subsystem. We need
to pass in that it is using the core AS version 7.1.2.Final (i.e. the
<code>ModelTestControllerVersion.V7_1_2_FINAL</code> part) and that that version is
ModelVersion 1.0.0. Next we have some <code>addMavenResourceURL()</code> calls
passing in the Maven GAVs of the old version of the subsystem and any
dependencies it has needed to boot up. Normally, specifying just the
Maven GAV of the old version of the subsystem is enough, but that
depends on your subsystem. In this case the old subsystem GAV is enough.
When booting up the legacy controller the framework uses the parsed
operations from the main controller and transforms them using the 1.0.0
transformer in the threads subsystem. The
<code>addOperationValidationResolve()</code> and <code>excludeFromParent()</code> calls are
not normally necessary, see the javadoc for more examples.</p>
</div>
<div class="paragraph">
<p>The call to <code>KernelServicesBuilder.build()</code> will build both the main
controller and the legacy controller. As part of that it also boots up a
second copy of the main controller using the transformed operations to
make sure that the 'old' ops to boot our subsystem will still work on
the current controller, which is important for backwards compatibility
of CLI scripts. To tweak how that is done if you see failures there, see
<code>LegacyKernelServicesInitializer.skipReverseControllerCheck()</code> and
<code>LegacyKernelServicesInitializer.configureReverseControllerCheck()</code>. The
<code>LegacyKernelServicesInitializer</code> is what gets returned by
<code>KernelServicesBuilder.createLegacyKernelServicesBuilder()</code>.</p>
</div>
<div class="paragraph">
<p>Finally we call <code>checkSubsystemModelTransformation()</code> which reads the
full legacy subsystem model. The legacy subsystem model will have been
built up from the transformed boot operations from the parsed xml. The
operations get transformed by the operation transformers. Then it takes
the model of the current subsystem and transforms that using the
resource transformers. Then it compares the two models, which should be
the same. In some rare cases it is not possible to get those two models
exactly the same, so there is a version of this method that takes a
<code>ModelFixer</code> to make adjustments. The
<code>checkSubsystemModelTransformation()</code> method also makes sure that the
legacy model is valid according to the legacy subsystem&#8217;s resource
definition.</p>
</div>
<div class="paragraph">
<p>The legacy subsystem resource definitions are read on demand from the
legacy controller when the tests run. In some older versions of
subsystems (before we converted everything to use ResourceDefinition,
and DescriptionProvider implementations were coded by hand) there were
occasional problems with the resource definitions and they needed to be
touched up. In this case you can generate a new one, touch it up and
store the result in a file in the test resources under
<code>/same/package/as/the/test/class/{{subsystem-name</code>- <code>model-version</code>.
This will then prefer the file read from the file system to the one read
at runtime. To generate the .dmr file, you need to generate it by adding
a temporary test (make sure that you adjust <code>controllerVersion</code> and
<code>modelVersion</code> to what you want to generate):</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">    @Test
    public void deleteMeWhenDone() throws Exception {
        ModelTestControllerVersion controllerVersion = ModelTestControllerVersion.V7_1_2_FINAL;
        ModelVersion modelVersion = ModelVersion.create(1, 0, 0);
        KernelServicesBuilder builder = createKernelServicesBuilder(null);
 
        builder.createLegacyKernelServicesBuilder(null, controllerVersion, modelVersion)
            .addMavenResourceURL("org.jboss.as:jboss-as-threads:" + controllerVersion.getMavenGavVersion());
        KernelServices services = builder.build();
 
        generateLegacySubsystemResourceRegistrationDmr(services, modelVersion);
    }</code></pre>
</div>
</div>
<div class="paragraph">
<p>Now run the test and delete it. The legacy .dmr file should be in
<code>target/test-classes/org/jboss/as/subsystem/test/&lt;your-subsystem-name&gt;-&lt;your-version&gt;.dmr</code>.
Copy this .dmr file to the correct location in your project&#8217;s test
resources.</p>
</div>
</div>
<div class="sect2">
<h3 id="testing-a-configuration-that-does-not-work">Testing a configuration that does not work</h3>
<div class="paragraph">
<p>The <code>threads</code> subsystem (like several others) did not support the use of
expression values in the version that came with JBoss AS 7.1.2.Final. So
we have a test that attempts to use expressions, and then fixes each
resource and attribute where expressions were not allowed.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">    @Test
    public void testRejectExpressionsAS712() throws Exception {
        testRejectExpressions_1_0_0(ModelTestControllerVersion.V7_1_2_FINAL);
    }
 
    private void testRejectExpressions_1_0_0(ModelTestControllerVersion controllerVersion) throws Exception {
        // create builder for current subsystem version
        KernelServicesBuilder builder = createKernelServicesBuilder(createAdditionalInitialization());
 
        // create builder for legacy subsystem version
        ModelVersion version_1_0_0 = ModelVersion.create(1, 0, 0);
        builder.createLegacyKernelServicesBuilder(null, controllerVersion, version_1_0_0)
                .addMavenResourceURL("org.jboss.as:jboss-as-threads:" + controllerVersion.getMavenGavVersion())
                .excludeFromParent(SingleClassFilter.createFilter(ThreadsLogger.class));
 
        KernelServices mainServices = builder.build();
        KernelServices legacyServices = mainServices.getLegacyServices(version_1_0_0);
 
        Assert.assertNotNull(legacyServices);
        Assert.assertTrue("main services did not boot", mainServices.isSuccessfulBoot());
        Assert.assertTrue(legacyServices.isSuccessfulBoot());
 
        List&lt;ModelNode&gt; xmlOps = builder.parseXmlResource("expressions.xml");
 
        ModelTestUtils.checkFailedTransformedBootOperations(mainServices, version_1_0_0, xmlOps, getConfig());
    }</code></pre>
</div>
</div>
<div class="paragraph">
<p>Again we boot up a current and a legacy controller. However, note in
this case that they are both empty, no xml was parsed on boot so there
are no operations to boot up the model. Instead once the controllers
have been booted, we call <code>KernelServicesBuilder.parseXmlResource()</code>
which gets the operations from <code>expressions.xml</code>. <code>expressions.xml</code> uses
expressions in all the places they were not allowed in 7.1.2.Final. For
each resource <code>ModelTestUtils.checkFailedTransformedBootOperations()</code>
will check that the <code>add</code> operation gets rejected, and then correct one
attribute at a time until the resource has been totally corrected. Once
the <code>add</code> operation is totally correct, it will check that the add
operation no longer is rejected. The configuration for this is the
<code>FailedOperationTransformationConfig</code> returned by the <code>getConfig()</code>
method:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">    private FailedOperationTransformationConfig getConfig() {
        PathAddress subsystemAddress = PathAddress.pathAddress(ThreadsExtension.SUBSYSTEM_PATH);
        FailedOperationTransformationConfig.RejectExpressionsConfig allowedAndKeepalive =
                new FailedOperationTransformationConfig.RejectExpressionsConfig(PoolAttributeDefinitions.ALLOW_CORE_TIMEOUT, PoolAttributeDefinitions.KEEPALIVE_TIME);
...
        return new FailedOperationTransformationConfig()
                .addFailedAttribute(subsystemAddress.append(PathElement.pathElement(CommonAttributes.BLOCKING_BOUNDED_QUEUE_THREAD_POOL)),
                        allowedAndKeepalive)
                .addFailedAttribute(subsystemAddress.append(PathElement.pathElement(CommonAttributes.BOUNDED_QUEUE_THREAD_POOL)),
                        allowedAndKeepalive)
    }</code></pre>
</div>
</div>
<div class="paragraph">
<p>So what this means is that we expect the <code>allow-core-timeout</code> and
<code>keepalive-time</code> attributes for the
<code>blocking-bounded-queue-thread-pool=<strong></code> and <code>bounded-queue-thread-pool=</strong></code>
add operations to use expressions in the parsed xml. We then expect them
to fail since there should be transformers in place to reject
expressions, and correct them one at a time until the add operation
should pass. As well as doing the <code>add</code> operations the
<code>ModelTestUtils.checkFailedTransformedBootOperations()</code> method will also
try calling <code>write-attribute</code> for each attribute, correcting as it goes
along. As well as allowing you to test rejection of expressions
<code>FailedOperationTransformationConfig</code> also has some helper classes to
help testing rejection of other scenarios.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="common-transformation-use-cases">Common transformation use-cases</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Most transformations are quite similar, so this section covers some of
the actual transformation patterns found in the WildFly codebase. We
will look at the output of CompareModelVersionsUtil, and see what can be
done to transform for the older slave HCs. The examples come from the
WildFly codebase but are stripped down to focus solely on the use-case
being explained in an attempt to keep things as clear/simple as
possible.</p>
</div>
<div class="sect2">
<h3 id="child-resource-type-does-not-exist-in-legacy-model">Child resource type does not exist in legacy model</h3>
<div class="paragraph">
<p>Looking at the model comparison between WildFly and JBoss AS 7.2.0,
there is a change to the <code>remoting</code> subsystem. The relevant part of the
output is:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">======= Resource root address: ["subsystem" =&gt; "remoting"] - Current version: 2.0.0; legacy version: 1.2.0 =======
--- Problems for relative address to root []:
Missing child types in current: []; missing in legacy [http-connector]</code></pre>
</div>
</div>
<div class="paragraph">
<p>So our current model has added a child type called <code>http-connector</code>
which was not there in 7.2.0. This is configurable, and adds new
behavior, so it can not be part of a configuration sent across to a
legacy slave running version 1.2.0. So we add the following to
<code>RemotingExtension</code> to reject all instances of that child type against
ModelVersion 1.2.0.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">    @Override
    public void initialize(ExtensionContext context) {
        ....
        if (context.isRegisterTransformers()) {
            registerTransformers_1_1(registration);
            registerTransformers_1_2(registration);
        }
    }
 
    private void registerTransformers_1_2(SubsystemRegistration registration) {
        TransformationDescription.Tools.register(get1_2_0_1_3_0Description(), registration, VERSION_1_2);
    }
 
    private static TransformationDescription get1_2_0_1_3_0Description() {
        ResourceTransformationDescriptionBuilder builder = ResourceTransformationDescriptionBuilder.Factory.createSubsystemInstance();
        builder.rejectChildResource(HttpConnectorResource.PATH);
 
        return builder.build();
    }</code></pre>
</div>
</div>
<div class="paragraph">
<p>Since this child resource type also does not exist in ModelVersion 1.1.0
we need to reject it there as well using a similar mechanism.</p>
</div>
</div>
<div class="sect2">
<h3 id="attribute-does-not-exist-in-the-legacy-subsystem">Attribute does not exist in the legacy subsystem</h3>
<div class="sect3">
<h4 id="default-value-of-the-attribute-is-the-same-as-legacy-implied-behavior">Default value of the attribute is the same as legacy implied</h4>
<div class="paragraph">
<p>behavior</p>
</div>
<div class="paragraph">
<p>This example also comes from the <code>remoting</code> subsystem, and is probably
the most common type of transformation. The comparison tells us that
there is now an attribute under
<code>/subsystem=remoting/remote-outbound-connection=*</code> called <code>protocol</code>
which did not exist in the older version:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">======= Resource root address: ["subsystem" =&gt; "remoting"] - Current version: 2.0.0; legacy version: 1.2.0 =======
--- Problems for relative address to root []:
....
--- Problems for relative address to root ["remote-outbound-connection" =&gt; "*"]:
Missing attributes in current: []; missing in legacy [protocol]
Missing parameters for operation 'add' in current: []; missing in legacy [protocol]</code></pre>
</div>
</div>
<div class="paragraph">
<p>This difference also affects the <code>add</code> operation. Looking at the current
model the valid values for the <code>protocol</code> attribute are <code>remote</code>,
<code>http-remoting</code> and <code>https-remoting</code>. The last two are new protocols
introduced in WildFly {wildflyVersion}, meaning that the <em>implied behaviour</em> in JBoss
7.2.0 and earlier is the <code>remote</code> protocol. Since this attribute does
not exist in the legacy model we want to discard this attribute if it is
<code>undefined</code> or if it has the value <code>remote</code>, both of which are in line
with what the legacy slave HC is hardwired to use. Also we want to
reject it if it has a value different from <code>remote</code>. So what we need to
do when registering transformers against ModelVersion 1.2.0 to handle
this attribute:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">    private void registerTransformers_1_2(SubsystemRegistration registration) {
        TransformationDescription.Tools.register(get1_2_0_1_3_0Description(), registration, VERSION_1_2);
    }
 
    private static TransformationDescription get1_2_0_1_3_0Description() {
        ResourceTransformationDescriptionBuilder builder = ResourceTransformationDescriptionBuilder.Factory.createSubsystemInstance();
        protocolTransform(builder.addChildResource(RemoteOutboundConnectionResourceDefinition.ADDRESS)
                .getAttributeBuilder());
        return builder.build();
    }
 
    private static AttributeTransformationDescriptionBuilder protocolTransform(AttributeTransformationDescriptionBuilder builder) {
        builder.setDiscard(new DiscardAttributeChecker.DiscardAttributeValueChecker(new ModelNode(Protocol.REMOTE.toString())), RemoteOutboundConnectionResourceDefinition.PROTOCOL)
                .addRejectCheck(RejectAttributeChecker.DEFINED, RemoteOutboundConnectionResourceDefinition.PROTOCOL);
        return builder;
    }</code></pre>
</div>
</div>
<div class="paragraph">
<p>So the first thing to happens is that we register a
<code>DiscardAttributeChecker.DiscardAttributeValueChecker</code> which discards
the attribute if it is either <code>undefined</code> (the default value in the
current model is <code>remote</code>), or <code>defined</code> and has the value <code>remote</code>.
Remembering that the <code>discard</code> phase always happens before the <code>reject</code>
phase, the reject checker checks that the <code>protocol</code> attribute is
defined, and rejects it if it is. The only reason it would be <code>defined</code>
in the reject check, is if it was not discarded by the discard check.
Hopefully this example shows that the discard and reject checkers often
work in pairs.</p>
</div>
<div class="paragraph">
<p>An alternative way to write the <code>protocolTransform()</code> method would be:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">     private static AttributeTransformationDescriptionBuilder protocolTransform(AttributeTransformationDescriptionBuilder builder) {
        builder.setDiscard(new DiscardAttributeChecker.DefaultDiscardAttributeChecker() {
                    @Override
                    protected boolean isValueDiscardable(final PathAddress address, final String attributeName, final ModelNode attributeValue, final TransformationCon
                        return !attributeValue.isDefined() || attributeValue.asString().equals(Protocol.REMOTE.toString());
                    }
                }, RemoteOutboundConnectionResourceDefinition.PROTOCOL)
         .addRejectCheck(RejectAttributeChecker.DEFINED, RemoteOutboundConnectionResourceDefinition.PROTOCOL);
         return builder;</code></pre>
</div>
</div>
<div class="paragraph">
<p>The reject check remains the same, but we have implemented the discard
check by using <code>DiscardAttributeChecker.DefaultDiscardAttributeChecker</code>
instead. However, the effect of the discard check is exactly the same as
when we used <code>DiscardAttributeChecker.DiscardAttributeValueChecker</code>.</p>
</div>
</div>
<div class="sect3">
<h4 id="default-value-of-the-attribute-is-different-from-legacy-implied-behaviour">Default value of the attribute is different from legacy implied</h4>
<div class="paragraph">
<p>behaviour</p>
</div>
<div class="paragraph">
<p>We touched on this in the weld subsystem example we used earlier in this
guide, but let&#8217;s take a more thorough look. Our comparison tells us that
we have two new attributes <code>require-bean-descriptor</code> and
<code>non-portable-mode</code>:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>====== Resource root address: ["subsystem" =&gt; "weld"] - Current version: 2.0.0; legacy version: 1.0.0 =======
--- Problems for relative address to root []:
Missing attributes in current: []; missing in legacy [require-bean-descriptor, non-portable-mode]
Missing parameters for operation 'add' in current: []; missing in legacy [require-bean-descriptor, non-portable-mode]</pre>
</div>
</div>
<div class="paragraph">
<p>Now when we look at this we see that the default value for both of the
attributes in the current model is <code>false</code>, which allows us more
flexible behavior introduced in CDI 1.1 (which was introduced with this
version of the subsystem). The old model does not have these attributes,
and implements CDI 1.0, which under the hood (using our weld subsystem
expertise knowledge) implies the values <code>true</code> for both of these. So our
transformer must reject anything that is not <code>true</code> for these
attributes. Let us look at the transformer registered by the
WeldExtension:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">    private void registerTransformers(SubsystemRegistration subsystem) {
        ResourceTransformationDescriptionBuilder builder = TransformationDescriptionBuilder.Factory.createSubsystemInstance();
        //These new attributes are assumed to be 'true' in the old version but default to false in the current version. So discard if 'true' and reject if 'undefined'.
        builder.getAttributeBuilder()
                .setDiscard(new DiscardAttributeChecker.DiscardAttributeValueChecker(false, false, new ModelNode(true)),
                        WeldResourceDefinition.NON_PORTABLE_MODE_ATTRIBUTE, WeldResourceDefinition.REQUIRE_BEAN_DESCRIPTOR_ATTRIBUTE)
                .addRejectCheck(new RejectAttributeChecker.DefaultRejectAttributeChecker() {
 
                    @Override
                    public String getRejectionLogMessage(Map&lt;String, ModelNode&gt; attributes) {
                        return WeldMessages.MESSAGES.rejectAttributesMustBeTrue(attributes.keySet());
                    }
 
                    @Override
                    protected boolean rejectAttribute(PathAddress address, String attributeName, ModelNode attributeValue,
                            TransformationContext context) {
                        //This will not get called if it was discarded, so reject if it is undefined (default==false) or if defined and != 'true'
                        return !attributeValue.isDefined() || !attributeValue.asString().equals("true");
                    }
                }, WeldResourceDefinition.NON_PORTABLE_MODE_ATTRIBUTE, WeldResourceDefinition.REQUIRE_BEAN_DESCRIPTOR_ATTRIBUTE)
                .end();
        TransformationDescription.Tools.register(builder.build(), subsystem, ModelVersion.create(1, 0, 0));
    }</code></pre>
</div>
</div>
<div class="paragraph">
<p>This looks a bit more scary than the previous transformer we have seen,
but isn&#8217;t actually too bad. The first thing we do is register a
<code>DiscardAttributeChecker.DiscardAttributeValueChecker</code> which will
discard the attribute if it has the value <code>true</code>. It will not discard if
it is <code>undefined</code> since that defaults to <code>false</code>. This is registered for
both attributes.</p>
</div>
<div class="paragraph">
<p>If the attributes had the value <code>true</code> they will get discarded we will
not hit the reject checker since discarded attributes never get checked
for rejection. If on the other hand they were an expression (since we
are interested in the actual value, but cannot evaluate what value an
expression will resolve to on the target from the DC running the
transformers), <code>false</code>, or <code>undefined</code> (which will then default to
<code>false</code>) they will not get discarded and will need to be rejected. So
our
<code>RejectAttributeChecker.DefaultRejectAttributeChecker.rejectAttribute()</code>
method will return <code>true</code> (i.e. reject) if the attribute value is
<code>undefined</code> (since that defaults to <code>false</code>) or if it is defined and
'not equal to `true&#8217;. It is better to check for 'not equal to `true&#8217;
than to check for 'equal to `false&#8217; since if an expression was used we
still want to reject, and only the 'not equal to `true&#8217; check would
actually kick in in that case.</p>
</div>
<div class="paragraph">
<p>The other thing we need in our
<code>DiscardAttributeChecker.DiscardAttributeValueChecker</code> is to override
the <code>getRejectionLogMessage()</code> method to get the message to be displayed
when rejecting the transformation. In this case it says something along
the lines "These attributes must be 'true' for use with CDI 1.0 '%s'",
with the names of the attributes having been rejected substituting the
<code>%s</code>.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="attribute-has-a-different-default-value">Attribute has a different default value</h3>
<div class="paragraph">
<p>– TODO</p>
</div>
<div class="paragraph">
<p>(The gist of this is to use a value converter, such that if the
attribute is undefined, and hence the default value will take effect,
then the value gets converted to the current version&#8217;s default value.
This ensures that the legacy HC will use the same effective setting as
current version HCs.</p>
</div>
<div class="paragraph">
<p>Note however that a change in default values is a form of incompatible
API change, since CLI scripts written assuming the old defaults will now
produce a configuration that behaves differently. Transformers make it
possible to have a consistently configured domain even in the presence
of this kind of incompatible change, but that doesn&#8217;t mean such changes
are good practice. They are generally unacceptable in WildFly&#8217;s own
subsystems.</p>
</div>
<div class="paragraph">
<p>One trick to ameliorate the impact of a default value change is to
modify the xml parser for the <strong>old</strong> schema version such that if the xml
attribute is not configured, the parser sets the old default value for
the attribute, instead of <code>undefined</code>. This approach allows the parsing
of old config documents to produce results consistent with what happened
when they were created. It does not help with CLI scripts though.)</p>
</div>
</div>
<div class="sect2">
<h3 id="attribute-has-a-different-type">Attribute has a different type</h3>
<div class="paragraph">
<p>Here the example comes from the <code>capacity</code> parameter some way into the
<code>modcluster</code> subsystem, and the legacy version is AS 7.1.2.Final. There
are quite a few differences, so I am only showing the ones relevant for
this example:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>====== Resource root address: ["subsystem" =&gt; "modcluster"] - Current version: 2.0.0; legacy version: 1.2.0 =======
...
--- Problems for relative address to root ["mod-cluster-config" =&gt; "configuration","dynamic-load-provider" =&gt; "configuration","custom-load-m
etric" =&gt; "*"]:
Different 'type' for attribute 'capacity'. Current: DOUBLE; legacy: INT
Different 'expressions-allowed' for attribute 'capacity'. Current: true; legacy: false
...
Different 'type' for parameter 'capacity' of operation 'add'. Current: DOUBLE; legacy: INT
Different 'expressions-allowed' for parameter 'capacity' of operation 'add'. Current: true; legacy: false</pre>
</div>
</div>
<div class="paragraph">
<p>So as we can see expressions are not allowed for the <code>capacity</code>
attribute, and the current type is <code>double</code> while the legacy subsystem
is <code>int</code>. So this means that if the value is for example <code>2.0</code> we can
convert this to <code>2</code>, but <code>2.5</code> cannot be converted. The way this is
solved in the ModClusterExtension is to register the following some
other attributes are registered here, but hopefully it is clear anyway:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">        dynamicLoadProvider.addChildResource(LOAD_METRIC_PATH)
                    .getAttributeBuilder()
                        .addRejectCheck(RejectAttributeChecker.SIMPLE_EXPRESSIONS, TYPE, WEIGHT, CAPACITY, PROPERTY)
                        .addRejectCheck(CapacityCheckerAndConverter.INSTANCE, CAPACITY)
                        .setValueConverter(CapacityCheckerAndConverter.INSTANCE, CAPACITY)
                        ...
                        .end();</code></pre>
</div>
</div>
<div class="paragraph">
<p>So we register that we should reject expressions, and we also register
the <code>CapacityCheckerAndConverter</code> for <code>capacity</code>.
<code>CapacityCheckerAndConverter</code> extends the convenience class
<code>DefaultCheckersAndConverter</code> which implements the
<code>DiscardAttributeChecker</code>, <code>RejectAttributeChecker</code>, and
<code>AttributeConverter</code> interfaces. We have seen <code>DiscardAttributeChecker</code>
and <code>RejectAttributeChecker</code> in previous examples. Since we now need to
convert a value we need an instance of <code>AttributeConverter</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">    static class CapacityCheckerAndConverter extends DefaultCheckersAndConverter {
 
        static final CapacityCheckerAndConverter INSTANCE = new CapacityCheckerAndConverter();</code></pre>
</div>
</div>
<div class="paragraph">
<p>We should not discard so <code>isValueDiscardable()</code> from
<code>DiscardAttributeChecker</code> always returns <code>false</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">        @Override
        protected boolean isValueDiscardable(PathAddress address, String attributeName, ModelNode attributeValue, TransformationContext context) {
            //Not used for discard
            return false;
        }
 
        @Override
        public String getRejectionLogMessage(Map&lt;String, ModelNode&gt; attributes) {
            return ModClusterMessages.MESSAGES.capacityIsExpressionOrGreaterThanIntegerMaxValue(attributes.get(CAPACITY.getName()));
        }</code></pre>
</div>
</div>
<div class="paragraph">
<p>Now we check to see if we can convert the attribute to an <code>int</code> and
reject if not. Note that if it is an expression, we have no idea what
its value will resolve to on the target host, so we need to reject it.
Then we try to change it into an <code>int</code>, and reject if that was not
possible:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">        @Override
        protected boolean rejectAttribute(PathAddress address, String attributeName, ModelNode attributeValue, TransformationContext context) {
            if (checkForExpression(attributeValue)
                    || (attributeValue.isDefined() &amp;&amp; !isIntegerValue(attributeValue.asDouble()))) {
                return true;
            }
            Long converted = convert(attributeValue);
            return (converted != null &amp;&amp; (converted &gt; Integer.MAX_VALUE || converted &lt; Integer.MIN_VALUE));
        }</code></pre>
</div>
</div>
<div class="paragraph">
<p>And then finally we do the conversion:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">        @Override
        protected void convertAttribute(PathAddress address, String attributeName, ModelNode attributeValue, TransformationContext context) {
            Long converted = convert(attributeValue);
            if (converted != null &amp;&amp; converted &lt;= Integer.MAX_VALUE &amp;&amp; converted &gt;= Integer.MIN_VALUE) {
                attributeValue.set((int)converted.longValue());
            }
        }
 
 
        private Long convert(ModelNode attributeValue) {
            if (attributeValue.isDefined() &amp;&amp; !checkForExpression(attributeValue)) {
                double raw = attributeValue.asDouble();
                if (isIntegerValue(raw)) {
                    return Math.round(raw);
                }
            }
            return null;
        }
 
        private boolean isIntegerValue(double raw) {
            return raw == Double.valueOf(Math.round(raw)).doubleValue();
        }
 
    }</code></pre>
</div>
</div>
</div>
</div>
</div>
      </div>
    </main><footer class="site-footer h-card">
  <data class="u-url" href="/wildflysite/"></data>

  <div class="wrapper">

    <h2 class="footer-heading">Wildfly</h2>

    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <li class="p-name">Wildfly</li></ul>
      </div>

      <div class="footer-col footer-col-2"><ul class="social-media-list"><li><a href="https://github.com/wildfly"><svg class="svg-icon"><use xlink:href="/wildflysite/assets/minima-social-icons.svg#github"></use></svg> <span class="username">wildfly</span></a></li><li><a href="https://www.twitter.com/WildFlyAS"><svg class="svg-icon"><use xlink:href="/wildflysite/assets/minima-social-icons.svg#twitter"></use></svg> <span class="username">WildFlyAS</span></a></li></ul>
</div>

      <div class="footer-col footer-col-3">
        <p></p>
      </div>
    </div>

  </div>

</footer>
</body>

</html>
