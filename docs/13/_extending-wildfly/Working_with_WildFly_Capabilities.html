<!DOCTYPE html>
<html lang="en"><head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1"><!-- Begin Jekyll SEO tag v2.5.0 -->
<title>Working with WildFly Capabilities | Wildfly</title>
<meta name="generator" content="Jekyll v3.8.3" />
<meta property="og:title" content="Working with WildFly Capabilities" />
<meta property="og:locale" content="en_US" />
<link rel="canonical" href="https://jbossorg.github.io/wildflysite/docs/13/_extending-wildfly/Working_with_WildFly_Capabilities.html" />
<meta property="og:url" content="https://jbossorg.github.io/wildflysite/docs/13/_extending-wildfly/Working_with_WildFly_Capabilities.html" />
<meta property="og:site_name" content="Wildfly" />
<script type="application/ld+json">
{"@type":"WebPage","url":"https://jbossorg.github.io/wildflysite/docs/13/_extending-wildfly/Working_with_WildFly_Capabilities.html","headline":"Working with WildFly Capabilities","@context":"http://schema.org"}</script>
<!-- End Jekyll SEO tag -->
<link rel="stylesheet" href="/wildflysite/assets/main.css"><link type="application/atom+xml" rel="alternate" href="https://jbossorg.github.io/wildflysite/feed.xml" title="Wildfly" /></head>
<body><div class="header navigation">
  <div class="logo-wrapper">
    <a href="/wildflysite/"><img class="wf-logo" src="/wildflysite/assets/img/wildfly_icons_one-color-logo.png"></a>
  </div>
  <div class="nav-container">
    <nav>
      <div class="nav-mobile"><a id="nav-toggle" href="#!"><span></span></a></div>
      <ul class="nav-list">
        <li>
          <a href="/wildflysite/" class="">Home</a>
        </li>
        <li>
          <a href="/wildflysite/downloads/" class="">Downloads</a>
        </li>
        <li>
          <a href="/wildflysite/blog/" class="">Blog</a>
        </li>
        <li>
          <a href="/wildflysite/about/" class="">About</a>
        </li>
        <li>
          <a href="/wildflysite/contribute/" class="">Contribute</a>
        </li>
        <li>
          <a href="/wildflysite/docs/" class="">Docs</a>
        </li>
        <li>
          <a class="button-cta secondary" href="https://github.com/wildfly/wildfly/fork" target="_blank">Fork</a>
        </li>
      </ul>
    </nav>
  </div>
</div>
<main class="page-content" aria-label="Content">
      <div class="wrapper">
        <div id="preamble">
<div class="sectionbody">
<div class="paragraph">
<p>An extension to WildFly will likely want to make use of services
provided by the WildFly kernel, may want to make use of services
provided by other subsystems, and may wish to make functionality
available to other extensions. Each of these cases involves integration
between different parts of the system. In releases prior to WildFly 10,
this kind of integration was done on an ad-hoc basis, resulting in
overly tight coupling between different parts of the system and overly
weak integration contracts. For example, a service installed by
subsystem A might depend on a service installed by subsystem B, and to
record that dependency A&#8217;s authors copy a ServiceName from B&#8217;s code, or
even refer to a constant or static method from B&#8217;s code. The result is
B&#8217;s code cannot evolve without risking breaking A. And the authors of B
may not even intend for other subsystems to use its services. There is
no proper integration contract between the two subsystems.</p>
</div>
<div class="paragraph">
<p>Beginning with WildFly Core 2 and WildFly 10 the WildFly kernel&#8217;s
management layer provides a mechanism for allowing different parts of
the system to integrate with each other in a loosely coupled manner.
This is done via WildFly Capabilities. Use of capabilities provides the
following benefits:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>A standard way for system components to define integration contracts
for their use by other system components.</p>
</li>
<li>
<p>A standard way for system components to access integration contracts
provided by other system components.</p>
</li>
<li>
<p>A mechanism for configuration model referential integrity checking,
such that if one component&#8217;s configuration has an attribute that refers
to an other component (e.g. a <code>socket-binding</code> attribute in a subsystem
that opens a socket referring to that socket&#8217;s configuration), the
validity of that reference can be checked when validating the
configuration model.</p>
</li>
</ol>
</div>
</div>
</div>
<div class="sect1">
<h2 id="capabilities">Capabilities</h2>
<div class="sectionbody">
<div class="paragraph">
<p>A capability is a piece of functionality used in a WildFly Core based
process that is exposed via the WildFly Core management layer.
Capabilities may depend on other capabilities, and this interaction
between capabilities is mediated by the WildFly Core management layer.</p>
</div>
<div class="paragraph">
<p>Some capabilities are automatically part of a WildFly Core based
process, but in most cases the configuration provided by the end user
(i.e. in standalone.xml, domain.xml and host.xml) determines what
capabilities are present at runtime. It is the responsibility of the
handlers for management operations to register capabilities and to
register any requirements those capabilities may have for the presence
of other capabilities. This registration is done during the MODEL stage
of operation execution</p>
</div>
<div class="paragraph">
<p>A capability has the following basic characteristics:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>It has a name.</p>
</li>
<li>
<p>It may install an MSC service that can be depended upon by services
installed by other capabilities. If it does, it provides a mechanism for
discovering the name of that service.</p>
</li>
<li>
<p>It may expose some other API not based on service dependencies
allowing other capabilities to integrate with it at runtime.</p>
</li>
<li>
<p>It may depend on, or <strong>require</strong> other capabilities.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>During boot of the process, and thereafter whenever a management
operation makes a change to the process' configuration, at the end of
the MODEL stage of operation execution the kernel management layer will
validate that all capabilities required by other capabilities are
present, and will fail any management operation step that introduced an
unresolvable requirement. This will be done before execution of the
management operation proceeds to the RUNTIME stage, where interaction
with the process' MSC Service Container is done. As a result, in the
RUNTIME stage the handler for an operation can safely assume that the
runtime services provided by a capability for which it has registered a
requirement are available.</p>
</div>
<div class="sect2">
<h3 id="comparison-to-other-concepts">Comparison to other concepts</h3>
<div class="sect3">
<h4 id="capabilities-vs-modules">Capabilities vs modules</h4>
<div class="paragraph">
<p>A JBoss Modules module is the means of making resources available to the
classloading system of a WildFly Core based process. To make a
capability available, you must package its resources in one or more
modules and make them available to the classloading system. But a module
is not a capability in and of itself, and simply copying a module to a
WildFly installation does not mean a capability is available. Modules
can include resources completely unrelated to management capabilities.</p>
</div>
</div>
<div class="sect3">
<h4 id="capabilities-vs-extensions">Capabilities vs Extensions</h4>
<div class="paragraph">
<p>An extension is the means by which the WildFly Core management layer is
made aware of manageable functionality that is not part of the WildFly
Core kernel. The extension registers with the kernel new management
resource types and handlers for operations on those resources. One of
the things a handler can do is register or unregister a capability and
its requirements. An extension may register a single capability,
multiple capabilities, or possibly none at all. Further, not all
capabilities are registered by extensions; the WildFly Core kernel
itself may register a number of different capabilities.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="capability-names">Capability Names</h3>
<div class="paragraph">
<p>Capability names are simple strings, with the dot character serving as a
separator to allow namespacing.</p>
</div>
<div class="paragraph">
<p>The 'org.wildfly' namespace is reserved for projects associated with the
WildFly organization on github ( <a href="https://github.com/wildfly" class="bare">https://github.com/wildfly</a>).</p>
</div>
</div>
<div class="sect2">
<h3 id="statically-vs-dynamically-named-capabilities">Statically vs Dynamically Named Capabilities</h3>
<div class="paragraph">
<p>The full name of a capability is either statically known, or it may
include a statically known base element and then a dynamic element. The
dynamic part of the name is determined at runtime based on the address
of the management resource that registers the capability. For example,
the management resource at the address
'/socket-binding-group=standard-sockets/socket-binding=web' will
register a dynamically named capability named
'org.wildlfy.network.socket-binding.web'. The
'org.wildlfy.network.socket-binding' portion is the static part of the
name.</p>
</div>
<div class="paragraph">
<p>All dynamically named capabilities that have the same static portion of
their name should provide a consistent feature set and set of
requirements.</p>
</div>
</div>
<div class="sect2">
<h3 id="service-provided-by-a-capability">Service provided by a capability</h3>
<div class="paragraph">
<p>Typically a capability functions by registering a service with the
WildFly process' MSC ServiceContainer, and then dependent capabilities
depend on that service. The WildFly Core management layer orchestrates
registration of those services and service dependencies by providing a
means to discover service names.</p>
</div>
</div>
<div class="sect2">
<h3 id="custom-integration-apis-provided-by-a-capability">Custom integration APIs provided by a capability</h3>
<div class="paragraph">
<p>Instead of or in addition to providing MSC services, a capability may
expose some other API to dependent capabilities. This API must be
encapsulated in a single class (although that class can use other
non-JRE classes as method parameters or return types).</p>
</div>
</div>
<div class="sect2">
<h3 id="capability-requirements">Capability Requirements</h3>
<div class="paragraph">
<p>A capability may rely on other capabilities in order to provide its
functionality at runtime. The management operation handlers that
register capabilities are also required to register their requirements.</p>
</div>
<div class="paragraph">
<p>There are three basic types of requirements a capability may have:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Hard requirements. The required capability must always be present for
the dependent capability to function.</p>
</li>
<li>
<p>Optional requirements. Some aspect of the configuration of the
dependent capability controls whether the depended on capability is
actually necessary. So the requirement cannot be known until the running
configuration is analyzed.</p>
</li>
<li>
<p>Runtime-only requirements. The dependent capability will check for the
presence of the depended upon capability at runtime, and if present it
will utilize it, but if it is not present it will function properly
without the capability. There is nothing in the dependent capability&#8217;s
configuration that controls whether the depended on capability must be
present. Only capabilities that declare themselves as being suitable for
use as a runtime-only requirement should be depended upon in this
manner.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Hard and optional requirements may be for either statically named or
dynamically named capabilities. Runtime-only requirements can only be
for statically named capabilities, as such a requirement cannot be
specified via configuration, and without configuration the dynamic part
of the required capability name is unknown.</p>
</div>
<div class="sect3">
<h4 id="supporting-runtime-only-requirements">Supporting runtime-only requirements</h4>
<div class="paragraph">
<p>Not all capabilities are usable as a runtime-only requirement.</p>
</div>
<div class="paragraph">
<p>Any dynamically named capability is not usable as a runtime-only
requirement.</p>
</div>
<div class="paragraph">
<p>For a capability to support use as a runtime-only requirement, it must
guarantee that a configuration change to a running process that removes
the capability will not impact currently running capabilities that have
a runtime-only requirement for it. This means:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>A capability that supports runtime-only usage must ensure that it
never removes its runtime service except via a full process reload.</p>
</li>
<li>
<p>A capability that exposes a custom integration API generally is not
usable as a runtime-only requirement. If such a capability does support
use as a runtime-only requirement, it must ensure that any functionality
provided via its integration API remains available as long as a full
process reload has not occurred.</p>
</li>
</ul>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="capability-contract">Capability Contract</h2>
<div class="sectionbody">
<div class="paragraph">
<p>A capability provides a stable contract to users of the capability. The
contract includes the following:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>The name of the capability (including whether it is dynamically
named).</p>
</li>
<li>
<p>Whether it installs an MSC Service, and if it does, the value type of
the service. That value type then becomes a stable API users of the
capability can rely upon.</p>
</li>
<li>
<p>Whether it provides a custom integration API, and if it does, the type
that represents that API. That type then becomes a stable API users of
the capability can rely upon.</p>
</li>
<li>
<p>Whether the capability supports use as a runtime-only requirement.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Developers can learn about available capabilities and the contracts they
provide by reading the WildFly <em>capabilty registry</em>.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="capability-registry">Capability Registry</h2>
<div class="sectionbody">
<div class="paragraph">
<p>The WildFly organization on github maintains a git repo where
information about available capabilities is published.</p>
</div>
<div class="paragraph">
<p><a href="https://github.com/wildfly/wildfly-capabilities" class="bare">https://github.com/wildfly/wildfly-capabilities</a></p>
</div>
<div class="paragraph">
<p>Developers can learn about available capabilities and the contracts they
provide by reading the WildFly capabilty registry.</p>
</div>
<div class="paragraph">
<p>The README.md file at the root of that repo explains the how to find out
information about the registry.</p>
</div>
<div class="paragraph">
<p>Developers of new capabilities are <strong>strongly encouraged</strong> to document and
register their capability by submitting a pull request to the
wildfly-capabilities github repo. This both allows others to learn about
your capability and helps prevent capability name collisions.
Capabilities that are used in the WildFly or WildFly Core code base
itself <strong>must</strong> have a registry entry before the code referencing them
will be merged.</p>
</div>
<div class="paragraph">
<p>External organizations that create capabilities should include an
organization-specific namespace as part their capability names to avoid
name collisions.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="using-capabilities">Using Capabilities</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Now that all the background information is presented, here are some
specifics about how to use WildFly capabilities in your code.</p>
</div>
<div class="sect2">
<h3 id="basics-of-using-your-own-capability">Basics of Using Your Own Capability</h3>
<div class="sect3">
<h4 id="creating-your-capability">Creating your capability</h4>
<div class="paragraph">
<p>A capability is an instance of the immutable
<code>org.jboss.as.controller.capability.RuntimeCapability</code> class. A
capability is usually registered by a resource, so the usual way to use
one is to store it in constant in the resource&#8217;s <code>ResourceDefinition</code>.
Use a <code>RuntimeCapability.Builder</code> to create one.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">class MyResourceDefinition extends SimpleResourceDefinition {

    static final RuntimeCapability&lt;Void&gt; FOO_CAPABILITY = RuntimeCapability.Builder.of("com.example.foo").build();
 
    . . .
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>That creates a statically named capability named <code>com.example.foo</code>.</p>
</div>
<div class="paragraph">
<p>If the capability is dynamically named, add the <code>dynamic</code> parameter to
state this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">    static final RuntimeCapability&lt;Void&gt; FOO_CAPABILITY =
            RuntimeCapability.Builder.of("com.example.foo", true).build();</code></pre>
</div>
</div>
<div class="paragraph">
<p>Most capabilities install a service that requiring capabilities can
depend on. If your capability does this, you need to declare the
service&#8217;s <em>value type</em> (the type of the object returned by
<code>org.jboss.msc.Service.getValue()</code>). For example, if FOO_CAPABILITY
provides a <code>Service&lt;javax.sql.DataSource&gt;</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">    static final RuntimeCapability&lt;Void&gt; FOO_CAPABILITY =
            RuntimeCapability.Builder.of("com.example.foo", DataSource.class).build();</code></pre>
</div>
</div>
<div class="paragraph">
<p>For a dynamic capability:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">    static final RuntimeCapability&lt;Void&gt; FOO_CAPABILITY =
           RuntimeCapability.Builder.of("com.example.foo", true, DataSource.class).build();</code></pre>
</div>
</div>
<div class="paragraph">
<p>If the capability provides a custom integration API, you need to
instantiate an instance of that API:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">public class JTSCapability {
 
    static final JTSCapability INSTANCE = new JTSCapability();
 
    private JTSCapability() {}
 
    /**
     * Gets the names of the {@link org.omg.PortableInterceptor.ORBInitializer} implementations that should be included
     * as part of the {@link org.omg.CORBA.ORB#init(String[], java.util.Properties) initialization of an ORB}.
     *
     * @return the names of the classes implementing {@code ORBInitializer}. Will not be {@code null}.
     */
    public List&lt;String&gt; getORBInitializerClasses() {
        return Collections.unmodifiableList(Arrays.asList(
            "com.arjuna.ats.jts.orbspecific.jacorb.interceptors.interposition.InterpositionORBInitializerImpl",
            "com.arjuna.ats.jbossatx.jts.InboundTransactionCurrentInitializer"));
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>and provide it to the builder:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">    static final RuntimeCapability&lt;JTSCapability&gt; FOO_CAPABILITY =
            RuntimeCapability.Builder.of("com.example.foo", JTSCapability.INSTANCE).build();</code></pre>
</div>
</div>
<div class="paragraph">
<p>For a dynamic capability:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">    static final RuntimeCapability&lt;JTSCapability&gt; FOO_CAPABILITY = RuntimeCapability.Builder.of("com.example.foo", true, JTSCapability.INSTANCE).build();</code></pre>
</div>
</div>
<div class="paragraph">
<p>A capability can provide both a custom integration API and install a
service:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">    static final RuntimeCapability&lt;JTSCapability&gt; FOO_CAPABILITY =
            RuntimeCapability.Builder.of("com.example.foo", JTSCapability.INSTANCE)
                .setServiceType(DataSource.class)
                .build();</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="registering-and-unregistering-your-capability">Registering and unregistering your capability</h4>
<div class="paragraph">
<p>Once you have your capability, you need to ensure it gets registered
with the WildFly Core kernel when your resource is added. This is easily
done simply by providing a reference to the capability to the resource&#8217;s
<code>ResourceDefinition</code>. This assumes your resource definition is a
subclass of the standard
<code>org.jboss.as.controller.SimpleResourceDefinition</code>.
<code>SimpleResourceDefinition</code> provides a <code>Parameters</code> class that provides a
builder-style API for setting up all the data needed by your definition.
This includes a <code>setCapabilities</code> method that can be used to declare the
capabilities provided by resources of this type.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">class MyResourceDefinition extends SimpleResourceDefinition {

    . . .
 
    MyResourceDefinition() {
        super(new SimpleResourceDefinition.Parameters(PATH, RESOLVER)
            .setAddHandler(MyAddHandler.INSTANCE)
            .setRemoveHandler(MyRemoveHandler.INSTANCE)
            .setCapabilities(FOO_CAPABILITY)
            );
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Your add handler needs to extend the standard
<code>org.jboss.as.controller.AbstractAddStepHandler</code> class or one of its
subclasses:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">class MyAddHandler extends AbstractAddStepHandler() {</code></pre>
</div>
</div>
<div class="paragraph">
<p>`AbstractAddStepHandler&#8217;s logic will register the capability when it
executes.</p>
</div>
<div class="paragraph">
<p>Your remove handler must also extend of the standard
<code>org.jboss.as.controller.AbstractRemoveStepHandler</code> or one of its
subclasses.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">class MyRemoveHandler extends AbstractRemoveStepHandler() {</code></pre>
</div>
</div>
<div class="paragraph">
<p>`AbstractRemoveStepHandler&#8217;s logic will deregister the capability when
it executes.</p>
</div>
<div class="paragraph">
<p>If for some reason you cannot base your <code>ResourceDefinition</code> on
<code>SimpleResourceDefinition</code> or your handlers on <code>AbstractAddStepHandler</code>
and <code>AbstractRemoveStepHandler</code> then you will need to take
responsibility for registering the capability yourself. This is not
expected to be a common situation. See the implementation of those
classes to see how to do it.</p>
</div>
</div>
<div class="sect3">
<h4 id="installing-accessing-and-removing-the-service-provided-by-your-capability">Installing, accessing and removing the service provided by your</h4>
<div class="paragraph">
<p>capability</p>
</div>
<div class="paragraph">
<p>If your capability installs a service, you should use the
<code>RuntimeCapability</code> when you need to determine the service&#8217;s name. For
example in the <code>Stage.RUNTIME</code> handling of your "add" step handler.
Here&#8217;s an example for a statically named capability:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">class MyAddHandler extends AbstractAddStepHandler() {
 
    . . .
 
    @Override
    protected void performRuntime(final OperationContext context, final ModelNode operation,
                                  final Resource resource) throws OperationFailedException {

        ServiceName serviceName = FOO_CAPABILITY.getCapabilityServiceName();
        Service&lt;DataSource&gt; service = createDataSourceService(context, resource);
        context.getServiceTarget().addService(serviceName, service).install();

    }</code></pre>
</div>
</div>
<div class="paragraph">
<p>If the capability is dynamically named, get the dynamic part of the name
from the <code>OperationContext</code> and use that when getting the service name:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">class MyAddHandler extends AbstractAddStepHandler() {
 
    . . .
 
    @Override
    protected void performRuntime(final OperationContext context, final ModelNode operation,
                                  final Resource resource) throws OperationFailedException {

        String myName = context.getCurrentAddressValue();
        ServiceName serviceName = FOO_CAPABILITY.getCapabilityServiceName(myName);
        Service&lt;DataSource&gt; service = createDataSourceService(context, resource);
        context.getServiceTarget().addService(serviceName, service).install();

    }</code></pre>
</div>
</div>
<div class="paragraph">
<p>The same patterns should be used when accessing or removing the service
in handlers for <code>remove</code>, <code>write-attribute</code> and custom operations.</p>
</div>
<div class="paragraph">
<p>If you use <code>ServiceRemoveStepHandler</code> for the <code>remove</code> operation, simply
provide your <code>RuntimeCapability</code> to the <code>ServiceRemoveStepHandler</code>
constructor and it will automatically remove your capability&#8217;s service
when it executes.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="basics-of-using-other-capabilities">Basics of Using Other Capabilities</h3>
<div class="paragraph">
<p>When a capability needs another capability, it only refers to it by its
string name. A capability should not reference the <code>RuntimeCapability</code>
object of another capability.</p>
</div>
<div class="paragraph">
<p>Before a capability can look up the service name for a required
capability&#8217;s service, or access its custom integration API, it must
first register a requirement for the capability. This must be done in
Stage.MODEL, while service name lookups and accessing the custom
integration API is done in Stage.RUNTIME.</p>
</div>
<div class="paragraph">
<p>Registering a requirement for a capability is simple.</p>
</div>
<div class="sect3">
<h4 id="registering-a-hard-requirement-for-a-static-capability">Registering a hard requirement for a static capability</h4>
<div class="paragraph">
<p>If your capability has a hard requirement for a statically named
capability, simply declare that to the builder for your
<code>RuntimeCapability</code>. For example, WildFly&#8217;s JTS capability requires both
a basic transaction support capability and IIOP capabilities:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">    static final RuntimeCapability&lt;JTSCapability&gt; JTS_CAPABILITY =
            RuntimeCapability.Builder.of("org.wildfly.transactions.jts", new JTSCapability())
                .addRequirements("org.wildfly.transactions", "org.wildfly.iiop.orb", "org.wildfly.iiop.corba-naming")
                .build();</code></pre>
</div>
</div>
<div class="paragraph">
<p>When your capability is registered with the system, the WildFly Core
kernel will automatically register any static hard requirements declared
this way.</p>
</div>
</div>
<div class="sect3">
<h4 id="registering-a-requirement-for-a-dynamically-named-capability">Registering a requirement for a dynamically named capability</h4>
<div class="paragraph">
<p>If the capability you require is dynamically named, usually your
capability&#8217;s resource will include an attribute whose value is the
dynamic part of the required capability&#8217;s name. You should declare this
fact in the <code>AttributeDefinition</code> for the attribute using the
<code>SimpleAttributeDefinitionBuilder.setCapabilityReference</code> method.</p>
</div>
<div class="paragraph">
<p>For example, the WildFly "remoting" subsystem&#8217;s
"org.wildfly.remoting.connector" capability has a requirement for a
dynamically named socket-binding capability:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">public class ConnectorResource extends SimpleResourceDefinition {
 
    . . .
 
    static final String SOCKET_CAPABILITY_NAME = "org.wildfly.network.socket-binding";
    static final RuntimeCapability&lt;Void&gt; CONNECTOR_CAPABILITY =
            RuntimeCapability.Builder.of("org.wildfly.remoting.connector", true)
                    .build();
 
    . . .
 
    static final SimpleAttributeDefinition SOCKET_BINDING =
            new SimpleAttributeDefinitionBuilder(CommonAttributes.SOCKET_BINDING, ModelType.STRING, false)
                .addAccessConstraint(SensitiveTargetAccessConstraintDefinition.SOCKET_BINDING_REF)
                .setCapabilityReference(SOCKET_CAPABILITY_NAME, CONNECTOR_CAPABILITY)
                .build();</code></pre>
</div>
</div>
<div class="paragraph">
<p>If the "add" operation handler for your resource extends
<code>AbstractAddStepHandler</code> and the handler for <code>write-attribute</code> extends
<code>AbstractWriteAttributeHandler</code>, the declaration above is sufficient to
ensure that the appropriate capability requirement will be registered
when the attribute is modified.</p>
</div>
</div>
<div class="sect3">
<h4 id="depending-upon-a-service-provided-by-another-capability">Depending upon a service provided by another capability</h4>
<div class="paragraph">
<p>Once the requirement for the capability is registered, your
<code>OperationStepHandler</code> can use the <code>OperationContext</code> to discover the
name of the service provided by the required capability.</p>
</div>
<div class="paragraph">
<p>For example, the "add" handler for a remoting connector uses the
<code>OperationContext</code> to find the name of the needed \{{SocketBinding}
service:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">        final String socketName = ConnectorResource.SOCKET_BINDING.resolveModelAttribute(context, fullModel).asString();
        final ServiceName socketBindingName = context.getCapabilityServiceName(ConnectorResource.SOCKET_CAPABILITY_NAME, socketName, SocketBinding.class);</code></pre>
</div>
</div>
<div class="paragraph">
<p>That service name is then used to add a dependency on the
<code>SocketBinding</code> service to the remoting connector service.</p>
</div>
<div class="paragraph">
<p>If the required capability isn&#8217;t dynamically named, <code>OperationContext</code>
exposes an overloaded <code>getCapabilityServiceName</code> variant. For example,
if a capability requires a remoting Endpoint:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">        ServiceName endpointService = context.getCapabilityServiceName("org.wildfly.remoting.endpoint", Endpoint.class);</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="using-a-custom-integration-api-provided-by-another-capability">Using a custom integration API provided by another capability</h4>
<div class="paragraph">
<p>In your <code>Stage.RUNTIME</code> handler, use
<code>OperationContext.getCapabilityRuntimeAPI</code> to get a reference to the
required capability&#8217;s custom integration API. Then use it as necessary.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">        List&lt;String&gt; orbInitializers = new ArrayList&lt;String&gt;();
        . . .
        JTSCapability jtsCapability = context.getCapabilityRuntimeAPI(IIOPExtension.JTS_CAPABILITY, JTSCapability.class);
        orbInitializers.addAll(jtsCapability.getORBInitializerClasses());</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="runtime-only-requirements">Runtime-only requirements</h4>
<div class="paragraph">
<p>If your capability has a runtime-only requirement for another
capability, that means that if that capability is present in
<code>Stage.RUNTIME</code> you&#8217;ll use it, and if not you won&#8217;t. There is nothing
about the configuration of your capability that triggers the need for
the other capability; you&#8217;ll just use it if it&#8217;s there.</p>
</div>
<div class="paragraph">
<p>In this case, use <code>OperationContext.hasOptionalCapability</code> in your
<code>Stage.RUNTIME</code> handler to check if the capability is present:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">    protected void performRuntime(final OperationContext context, final ModelNode operation, final ModelNode model) throws OperationFailedException {
 
        ServiceName myServiceName = MyResource.FOO_CAPABILITY.getCapabilityServiceName();
        Service&lt;DataSource&gt; myService = createService(context, model);
        ServiceBuilder&lt;DataSource&gt; builder = context.getTarget().addService(myServiceName, myService);
 
        // Inject a "Bar" into our "Foo" if bar capability is present
        if (context.hasOptionalCapability("com.example.bar", MyResource.FOO_CAPABILITY.getName(), null) {
            ServiceName barServiceName = context.getCapabilityServiceName("com.example.bar", Bar.class);
            builder.addDependency(barServiceName, Bar.class, myService.getBarInjector());
        }
 
        builder.install();
    }</code></pre>
</div>
</div>
<div class="paragraph">
<p>The WildFly Core kernel will not register a requirement for the
"com.example.bar" capability, so if a configuration change occurs that
means that capability will no longer be present, that change will not be
rolled back. Because of this, runtime-only requirements can only be used
with capabilities that declare in their contract that they support such
use.</p>
</div>
</div>
<div class="sect3">
<h4 id="using-a-capability-in-a-deploymentunitprocessor">Using a capability in a DeploymentUnitProcessor</h4>
<div class="paragraph">
<p>A <code>DeploymentUnitProcessor</code> is likely to have a need to interact with
capabilities, in order to create service dependencies from a deployment
service to a capability provided service or to access some aspect of a
capability&#8217;s custom integration API that relates to deployments.</p>
</div>
<div class="paragraph">
<p>If a <code>DeploymentUnitProcessor</code> associated with a capability
implementation needs to utilize its own capability object, the
<code>DeploymentUnitProcessor</code> authors should simply provide it with a
reference to the <code>RuntimeCapability</code> instance. Service name lookups or
access to the capabilities custom integration API can then be performed
by invoking the methods on the <code>RuntimeCapability</code>.</p>
</div>
<div class="paragraph">
<p>If you need to access service names or a custom integration API
associated with a different capability, you will need to use the
<code>org.jboss.as.controller.capability.CapabilityServiceSupport</code> object
associated with the deployment unit. This can be found as an attachment
to the <code>DeploymentPhaseContext</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">class MyDUP implements DeploymentUntiProcessor {
 
    public void deploy(DeploymentPhaseContext phaseContext) throws DeploymentUnitProcessingException {
 
        AttachmentKey&lt;CapabilityServiceSupport&gt; key = org.jboss.as.server.deployment.Attachments.DEPLOYMENT_COMPLETE_SERVICES;
        CapabilityServiceSupport capSvcSupport = phaseContext.getAttachment(key);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Once you have the <code>CapabilityServiceSupport</code> you can use it to look up
service names:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">        ServiceName barSvcName = capSvcSupport.getCapabilityServiceName("com.example.bar");
        // Determine what 'baz' the user specified in the deployment descriptor
        String bazDynamicName = getSelectedBaz(phaseContext);
        ServiceName bazSvcName = capSvcSupport.getCapabilityServiceName("com.example.baz", bazDynamicName);</code></pre>
</div>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<div class="title">Important</div>
</td>
<td class="content">
It&#8217;s important to note that when you request a service name associated
with a capability, the <code>CapabilityServiceSupport</code> will give you one
regardless of whether the capability is actually registered with the
kernel. If the capability isn&#8217;t present, any service dependency your DUP
creates using that service name will eventually result in a service
start failure, due to the missing dependency. This behavior of not
failing immediately when the capability service name is requested is
deliberate. It allows deployment operations that use the
<code>rollback-on-runtime-failure=false</code> header to successfully install (but
not start) all of the services related to a deployment. If a subsequent
operation adds the missing capability, the missing service dependency
problem will then be resolved and the MSC service container will
automatically start the deployment services.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>You can also use the <code>CapabilityServiceSupport</code> to obtain a reference to
the capability&#8217;s custom integration API:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">        // We need custom integration with the baz capability beyond service injection
        BazIntegrator bazIntegrator;
        try {
            bazIntegrator = capSvcSupport.getCapabilityRuntimeAPI("com.example.baz", bazDynamicName, BazIntegrator.class);
        } catch (NoSuchCapabilityException e) {
            //
            String msg = String.format("Deployment %s requires use of the 'bar' capability but it is not currently registered",
                                       phaseContext.getDeploymentUnit().getName());
            throw new DeploymentUnitProcessingException(msg);
        }</code></pre>
</div>
</div>
<div class="paragraph">
<p>Note that here, unlike the case with service name lookups, the
<code>CapabilityServiceSupport</code> will throw a checked exception if the desired
capability is not installed. This is because the kernel has no way to
satisfy the request for a custom integration API if the capability is
not installed. The <code>DeploymentUnitProcessor</code> will need to catch and
handle the exception.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="detailed-api">Detailed API</h3>
<div class="paragraph">
<p>The WildFly Core kernel&#8217;s API for using capabilities is covered in
detail in the javadoc for the
<a href="https://github.com/wildfly/wildfly-core/blob/master/controller/src/main/java/org/jboss/as/controller/capability/RuntimeCapability.java">RuntimeCapability
and RuntimeCapability.Builder</a> classes and the
<a href="https://github.com/wildfly/wildfly-core/blob/master/controller/src/main/java/org/jboss/as/controller/OperationContext.java">OperationContext</a>
and
<a href="https://github.com/wildfly/wildfly-core/blob/master/controller/src/main/java/org/jboss/as/controller/capability/CapabilityServiceSupport.java">CapabilityServiceSupport</a>
interfaces.</p>
</div>
<div class="paragraph">
<p>Many of the methods in <code>OperationContext</code> related to capabilities have
to do with registering capabilities or registering requirements for
capabilities. Typically non-kernel developers won&#8217;t need to worry about
these, as the abstract <code>OperationStepHandler</code> implementations provided
by the kernel take care of this for you, as described in the preceding
sections. If you do find yourself in a situation where you need to use
these in an extension, please read the javadoc thoroughly.</p>
</div>
</div>
</div>
</div>
      </div>
    </main><footer class="site-footer h-card">
  <data class="u-url" href="/wildflysite/"></data>

  <div class="wrapper">

    <h2 class="footer-heading">Wildfly</h2>

    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <li class="p-name">Wildfly</li></ul>
      </div>

      <div class="footer-col footer-col-2"><ul class="social-media-list"><li><a href="https://github.com/wildfly"><svg class="svg-icon"><use xlink:href="/wildflysite/assets/minima-social-icons.svg#github"></use></svg> <span class="username">wildfly</span></a></li><li><a href="https://www.twitter.com/WildFlyAS"><svg class="svg-icon"><use xlink:href="/wildflysite/assets/minima-social-icons.svg#twitter"></use></svg> <span class="username">WildFlyAS</span></a></li></ul>
</div>

      <div class="footer-col footer-col-3">
        <p></p>
      </div>
    </div>

  </div>

</footer>
</body>

</html>
