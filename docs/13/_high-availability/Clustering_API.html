<!DOCTYPE html>
<html lang="en"><head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1"><!-- Begin Jekyll SEO tag v2.5.0 -->
<title>Clustering_api | Wildfly</title>
<meta name="generator" content="Jekyll v3.8.3" />
<meta property="og:title" content="Clustering_api" />
<meta property="og:locale" content="en_US" />
<link rel="canonical" href="https://jbossorg.github.io/wildflysite/docs/13/_high-availability/Clustering_API.html" />
<meta property="og:url" content="https://jbossorg.github.io/wildflysite/docs/13/_high-availability/Clustering_API.html" />
<meta property="og:site_name" content="Wildfly" />
<script type="application/ld+json">
{"@type":"WebPage","url":"https://jbossorg.github.io/wildflysite/docs/13/_high-availability/Clustering_API.html","headline":"Clustering_api","@context":"http://schema.org"}</script>
<!-- End Jekyll SEO tag -->
<link rel="stylesheet" href="/wildflysite/assets/main.css"><link type="application/atom+xml" rel="alternate" href="https://jbossorg.github.io/wildflysite/feed.xml" title="Wildfly" /></head>
<body><div class="header navigation">
  <div class="logo-wrapper">
    <a href="/wildflysite/"><img class="wf-logo" src="/wildflysite/assets/img/wildfly_icons_one-color-logo.png"></a>
  </div>
  <div class="nav-container">
    <nav>
      <div class="nav-mobile"><a id="nav-toggle" href="#!"><span></span></a></div>
      <ul class="nav-list">
        <li>
          <a href="/wildflysite/" class="">Home</a>
        </li>
        <li>
          <a href="/wildflysite/downloads/" class="">Downloads</a>
        </li>
        <li>
          <a href="/wildflysite/blog/" class="">Blog</a>
        </li>
        <li>
          <a href="/wildflysite/about/" class="">About</a>
        </li>
        <li>
          <a href="/wildflysite/contribute/" class="">Contribute</a>
        </li>
        <li>
          <a href="/wildflysite/docs/" class="">Docs</a>
        </li>
        <li>
          <a class="button-cta secondary" href="https://github.com/wildfly/wildfly/fork" target="_blank">Fork</a>
        </li>
      </ul>
    </nav>
  </div>
</div>
<main class="page-content" aria-label="Content">
      <div class="wrapper">
        <div id="preamble">
<div class="sectionbody">
<div class="paragraph">
<p>WildFly exposes a public API to deployments for performing common clustering operations, such as:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="#group">Cluster membership introspection</a></p>
</li>
<li>
<p><a href="#command-dispatcher">Cluster command execution</a></p>
</li>
<li>
<p><a href="#service-provider-registry">A registry of service providers</a></p>
</li>
<li>
<p><a href="#registry">A member identification registry</a></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>This zero-dependency API allows an application to perform basic clustering tasks, while remaining decoupled from the libraries that implement WildFly&#8217;s clustering logic.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="group">Group membership</h2>
<div class="sectionbody">
<div class="paragraph">
<p>The Group abstraction represents a logical cluster of nodes.
The Group service provides the following capabilities:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>View the current membership of a group.</p>
</li>
<li>
<p>Identifies a designated coordinator for a given group membership. This designated coordinator will be the same on every node for a given membership. Traditionally, the oldest member of the cluster is chosen as the coordinator.</p>
</li>
<li>
<p>Registration facility for notifications of changes to group membership.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>WildFly creates a Group instance for every defined channel defined in the JGroups subsystem, as well as a local implementation.
The local Group implementation is effectively a singleton membership containing only the current node.
e.g.</p>
</div>
<div class="listingblock">
<div class="content">
<pre>@Resource(lookup = "java:jboss/clustering/group/ee") // A Group representing the cluster of the "ee" channel
private Group group;

@Resource(lookup = "java:jboss/clustering/group/local") // A non-clustered Group
private Group localGroup;</pre>
</div>
</div>
<div class="paragraph">
<p>To ensure that your application operates consistently regardless of server configuration, you are strongly recommended to reference a given Group using an alias.
Most users should use the "default" alias, which references either:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>A Group backed by the default channel of the server, if the JGroups subsystem is present</p>
</li>
<li>
<p>A non-clustered Group, if the JGroups subsystem is not present</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>e.g.</p>
</div>
<div class="listingblock">
<div class="content">
<pre>@Resource(lookup = "java:jboss/clustering/group/default")
private Group group;</pre>
</div>
</div>
<div class="paragraph">
<p>Additionally, WildFly creates a Group alias for every Infinispan cache-container, which references:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>A Group backed by the transport channel of the cache container</p>
</li>
<li>
<p>A non-clustered Group, if the cache container has no transport</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>This is useful when using a Group within the context of an Infinispan cache.</p>
</div>
<div class="paragraph">
<p>e.g.</p>
</div>
<div class="listingblock">
<div class="content">
<pre>@Resource(lookup = "java:jboss/clustering/group/server") // Backed by the transport of the "server" cache-container
private Group group;</pre>
</div>
</div>
<div class="sect2">
<h3 id="node">Node</h3>
<div class="paragraph">
<p>A Node encapsulates a member of a group (i.e. a JGroups address).
A Node has the following distinct characteristics, which will be unique for each member of the group:</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">getName</dt>
<dd>
<p>The distinct logical name of this group member.
This value inherently defaults to the hostname of the machine, and can be overridden via the "jboss.node.name" system property.
You must override this value if you run multiple servers on the same host.</p>
</dd>
<dt class="hdlist1">getSocketAddress()</dt>
<dd>
<p>The distinct bind address/port used by this group member.
This will be null if the group is non-clustered.</p>
</dd>
</dl>
</div>
</div>
<div class="sect2">
<h3 id="membership">Membership</h3>
<div class="paragraph">
<p>A Membership is an immutable encapsulation of a group membership (i.e. a JGroups view).
Membership exposes the following properties:</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">getMembers()</dt>
<dd>
<p>Returns the list of members comprising this group membership. The order of this list will be consistent on all nodes in the cluster.</p>
</dd>
<dt class="hdlist1">isCoordinator()</dt>
<dd>
<p>Indicates whether the current member is the coordinator of the group.</p>
</dd>
<dt class="hdlist1">getCoordinator()</dt>
<dd>
<p>Returns the member designated as coordinator of this group. This methods will return a consistent value for all nodes in the cluster.</p>
</dd>
</dl>
</div>
</div>
<div class="sect2">
<h3 id="usage">Usage</h3>
<div class="paragraph">
<p>The Group abstract is effectively a volatile reference to the current membership, and provides a facility for notification of membership changes.
It exposes the following properties and operations:</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">getName()</dt>
<dd>
<p>The logical name of this group.</p>
</dd>
<dt class="hdlist1">getLocalMember()</dt>
<dd>
<p>The Node instance corresponding to the local member.</p>
</dd>
<dt class="hdlist1">getMembership()</dt>
<dd>
<p>Returns the current membership of this group.</p>
</dd>
<dt class="hdlist1">register(GroupListener)</dt>
<dd>
<p>Registers the specific listener to be notified of changes to group membership.</p>
</dd>
<dt class="hdlist1">isSingleton()</dt>
<dd>
<p>Indicates whether the groups membership is non-clustered, i.e. will only ever contain a single member.</p>
</dd>
</dl>
</div>
</div>
<div class="sect2">
<h3 id="example">Example</h3>
<div class="paragraph">
<p>A distributed "Hello world" example that prints joiners and leavers of a group membership:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>public class MyGroupListener implements GroupListener {
    @Resource(lookup = "java:jboss/clustering/group/default") <b class="conum">(1)</b>
    private Group group;
    private Registration&lt;GroupListener&gt; listenerRegistration;

    @PostConstruct
    public void init() {
        this.listenerRegistration = this.group.register(this);
        System.out.println("Initial membership: " + this.group.getMembership().getMembers());
    }

    @PreDestroy
    public void destroy() {
        this.listenerRegistration.close(); <b class="conum">(2)</b>
    }

    @Override
    public void membershipChanged(Membership previous, Membership current, boolean merged) {
        List&lt;Node&gt; previousMembers = previous.getMembers();
        List&lt;Node&gt; currentMembers = current.getMembers();
        List&lt;Node&gt; joiners = currentMembers.stream().filter(member -&gt; !previousMembers.contains(member)).collect(Collectors.toList());
        if (!joiners.isEmpty()) {
            System.out.println("Welcome: " + joiners);
        }
        List&lt;Node&gt; leavers = previousMembers.stream().filter(member -&gt; !currentMembers.contains(member)).collect(Collectors.toList());
        if (!leavers.isEmpty()) {
            System.out.println("Goodbye: " + leavers);
        }
    }
}</pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Injects the default Group of the server</p>
</li>
<li>
<p>Make sure to close your listener registration!</p>
</li>
</ol>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="command-dispatcher">Command Dispatcher</h2>
<div class="sectionbody">
<div class="paragraph">
<p>A command dispatcher is a mechanism for dispatching commands to be executed on members of a group.</p>
</div>
<div class="sect2">
<h3 id="commanddispatcherfactory">CommandDispatcherFactory</h3>
<div class="paragraph">
<p>A command dispatcher is created from a CommandDispatcherFactory, an instance of which is created for every defined channel defined in the JGroups subsystem, as well as a local implementation.
e.g.</p>
</div>
<div class="listingblock">
<div class="content">
<pre>@Resource(lookup = "java:jboss/clustering/dispatcher/ee") // A command dispatcher factory backed by the "ee" channel
private CommandDispatcherFactory factory;

@Resource(lookup = "java:jboss/clustering/dispatcher/local") // The non-clustered command dispatcher factory
private CommandDispatcherFactory localFactory;</pre>
</div>
</div>
<div class="paragraph">
<p>To ensure that your application functions consistently regardless of server configuration, we recommended that you reference the CommandDispatcherFactory using an alias.
Most users should use the "default" alias, which references either:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>A CommandDispatcherFactory backed by the default channel of the server, if the JGroups subsystem is present</p>
</li>
<li>
<p>A non-clustered CommandDispatcherFactory, if the JGroups subsystem is not present</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>e.g.</p>
</div>
<div class="listingblock">
<div class="content">
<pre>@Resource(lookup = "java:jboss/clustering/dispatcher/default")
private CommandDispatcherFactory factory;</pre>
</div>
</div>
<div class="paragraph">
<p>Additionally, WildFly creates a CommandDispatcherFactory alias for every Infinispan cache-container, which references:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>A CommandDispatcherFactory backed by the transport channel of the cache container</p>
</li>
<li>
<p>A non-clustered CommandDispatcherFactory, if the cache container has no transport</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>This is useful in the case where a CommandDispatcher is used to communicate with members on which a given cache is deployed.</p>
</div>
<div class="paragraph">
<p>e.g.</p>
</div>
<div class="listingblock">
<div class="content">
<pre>@Resource(lookup = "java:jboss/clustering/dispatcher/server") // Backed by the transport of the "server" cache-container
private CommandDispatcherFactory factory;</pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="command">Command</h3>
<div class="paragraph">
<p>A Command encapsulates logic to be executed on a group member.
A Command can leverage 2 type of parameters during execution:</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Sender supplied parameters</dt>
<dd>
<p>These are member variables of the Command implementation itself, and are provided during construction of the Command object.
As properties of a serializable object, these must also be serializable.</p>
</dd>
<dt class="hdlist1">Receiver supplied parameters, i.e. local context</dt>
<dd>
<p>These are encapsulated in a single object, supplied during construction of the CommandDispatcher.
The command dispatcher passes the local context as a parameter to the Command.execute(&#8230;&#8203;) method.</p>
</dd>
</dl>
</div>
</div>
<div class="sect2">
<h3 id="commanddispatcher">CommandDispatcher</h3>
<div class="paragraph">
<p>The CommandDispatcherFactory creates a CommandDispatcher using a service identifier and a local context.
This service identifier is used to segregate commands from multiple command dispatchers.
A CommandDispatcher will only receive commands dispatched by a CommandDispatcher with the same service identifier.</p>
</div>
<div class="paragraph">
<p>Once created, a CommandDispatcher will locally execute any received commands until it is closed.
Once closed, a CommandDispatcher is no longer allowed to dispatch commands.</p>
</div>
<div class="paragraph">
<p>The functionality of a CommandDispatcher boils down to 2 operations:</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">executeOnMember(Command, Node)</dt>
<dd>
<p>Executes a given command on a specific group member.</p>
</dd>
<dt class="hdlist1">executeOnGroup(Command, Node&#8230;&#8203;)</dt>
<dd>
<p>Executes a given command on all members of the group, optionally excluding specific members</p>
</dd>
</dl>
</div>
<div class="paragraph">
<p>Both methods return responses as a <a href="https://docs.oracle.com/javase/8/docs/api/">CompletionStage</a>, allowing for asynchronous processing of responses as they complete.</p>
</div>
</div>
<div class="sect2">
<h3 id="example-2">Example</h3>
<div class="paragraph">
<p>To demonstrate how to use a CommandDispatcher, let&#8217;s create a distributed "hello world" application.</p>
</div>
<div class="paragraph">
<p>First, let&#8217;s create a simple HelloWorld interface which enables the caller to send a specific message to the entire group:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>public interface HelloWorld {
    void send(String message);
}</pre>
</div>
</div>
<div class="paragraph">
<p>Next, we need to define a local command execution context.
This should encapsulate any local information we need to make available to the execution of any command received by our CommandDispatcher.
For demonstration purposes, let&#8217;s make this a separate interface:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>public interface LocalContext {
    Node getLocalMember();
}</pre>
</div>
</div>
<div class="paragraph">
<p>Next we create a "hello world" Command that contains a message from the sender, and responds with a message of its own.</p>
</div>
<div class="listingblock">
<div class="content">
<pre>public class HelloWorldCommand implements Command&lt;String, LocalContext&gt; {
    private final String message;

    public HelloWorldCommand(String message) {
        this.message = message;
    }

    @Override
    public String execute(LocalContext context) {
        System.out.println(String.format("Received message: %s", this.message);
        return String.format("Hello from %s", context.getLocalMember().getName());
    }
}</pre>
</div>
</div>
<div class="paragraph">
<p>Finally, we create a @Singleton EJB that implements our HelloWorld interface:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>@Singleton
@Startup
@Local(HelloWorld.class)
public class CommandDispatcherBean implements HelloWorld, LocalContext {

    @Resource(lookup = "java:jboss/clustering/dispatcher/default") <b class="conum">(1)</b>
    private CommandDispatcherFactory factory;
    private CommandDispatcher&lt;LocalContext&gt; dispatcher;

    @PostConstruct
    public void init() {
        this.dispatcher = this.factory.createCommandDispatcher(this.getClass().getName(), this);
    }

    @PreDestroy
    public void destroy() {
        this.dispatcher.close(); <b class="conum">(2)</b>
    }

    @Override
    public Node getLocalMember() {
        return this.factory.getGroup().getLocalMember();
    }

    @Override
    public void send(String message) {
        Map&lt;Node, CompletionStage&lt;String&gt;&gt; responses = this.dispatcher.executeOnGroup(new HelloWorldCommand(message), this.factory.getGroup().getLocalMember()); <b class="conum">(3)</b>
        responses.values().forEach(stage -&gt; stage.exceptionally(Exception::getLocalizedMessage).thenAccept(System.out::println));
    }
}</pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Uses the default CommandDispatcherFactory of the server</p>
</li>
<li>
<p>Don&#8217;t forget to close your CommandDispatcher!</p>
</li>
<li>
<p>We don&#8217;t want to send the message to ourselves, so we exclude the local member</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Now you can use the HelloWorld.send(&#8230;&#8203;) operation to say hello to your cluster.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="service-provider-registry">Service Provider Registry</h2>
<div class="sectionbody">
<div class="paragraph">
<p>A service provider registry is a specialized cache that tracks the group members that provide a given service.
The ServiceProviderRegistry might be used in concert with a CommandDispatcher to communicate between a subset of group members on which a given service is installed.
It includes a registration facility to receive notifications when the set of nodes providing a given service changes.
WildFly uses this internally in its Singleton service/deployment implementation to drive the primary election process.</p>
</div>
<div class="paragraph">
<p>WildFly exposes a ServiceProviderRegistry (from which a ServiceProviderRegistration is created) for each cache defined by the Infinispan subsystem.</p>
</div>
<div class="sect2">
<h3 id="example-3">Example</h3>
<div class="paragraph">
<p>The following is an example of using a ServiceProviderRegistry to publish the availability of a given singleton EJB.
The getProviders() method will return the set of nodes on which the ServiceProviderRegistrationBean is deployed.</p>
</div>
<div class="listingblock">
<div class="content">
<pre>@Singleton
@Startup
@Local(ServiceProviderRegistry.class)
public class ServiceProviderRegistrationBean implements ServiceProviderRegistration&lt;String&gt;, ServiceProviderRegistration.Listener {
    @Resource(lookup = "java:jboss/clustering/providers/server/default") <b class="conum">(1)</b>
    private ServiceProviderRegistry registry;
    private ServiceProviderRegistration registration;

    @PostConstruct
    public void init() {
        this.registration = this.registry.register(this.getClass().getName(), this);
    }

    @PreDestroy
    public void destroy() {
        this.registration.close(); <b class="conum">(2)</b>
    }

    @Override
    public void providersChanged(Set&lt;Node&gt; providers) {
        System.out.println("%s is now available on the following nodes: %s", this.getClass().getName(), providers);
    }

    @Override
    public String getService() {
        return this.registration.getService();
    }

    @Override
    public Set&lt;Node&gt; getProviders() {
        return this.registration.getProviders();
    }

    @Override
    public void close() {
        // Do nothing - registration is close on bean destroy
    }
}</pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Uses the default cache of the "server" cache container.</p>
</li>
<li>
<p>Remember to close the registration!</p>
</li>
</ol>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="registry">Registry</h2>
<div class="sectionbody">
<div class="paragraph">
<p>A registry is a specialized cache for storing a unique key/value pair for each member of a group.
This is useful to bridge WildFly&#8217;s Group members to an internal identification system used by an application.
The Registry service includes a facility for notifying group members of new, updated, or obsolete registry entries.</p>
</div>
<div class="paragraph">
<p>WildFly exposes a RegistryFactory (from which a Registry is created) for each cache defined by the Infinispan subsystem.</p>
</div>
<div class="sect2">
<h3 id="example-4">Example</h3>
<div class="paragraph">
<p>The following Registry example assigns a UUID to each group member, allowing each member to query the identifier of any other member:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>@Singleton
@Startup
@Local(Registry.class)
public class RegistryBean implements Registry&lt;UUID, Void&gt; {
    @Resource(lookup = "java:jboss/clustering/registry/server/default") <b class="conum">(1)</b>
    private RegistryFactory&lt;UUID, Void&gt; factory;
    private Registry&lt;UUID, Void&gt; registry;

    @PostConstruct
    public void init() {
        this.registry = this.factory.createRegistry(new AbstractMap.SimpleImmutableEntry&lt;&gt;(UUID.randomUUID(), null);
    }

    @PreDestroy
    public void destroy() {
        this.registry.close(); <b class="conum">(2)</b>
    }

    @Override
    public Group getGroup() {
        return this.registry.getGroup();
    }

	@Override
	public Map&lt;UUID, Void&gt; getEntries() {
	    return this.registry.getEntries();
	}

    @Override
    public Map.Entry&lt;UUID, Void&gt; getEntry(Node node) {
        return this.registry.getEntry(node);
    }

    @Override
    public void close() {
        // Do nothing - registry is closed on bean destroy
    }
}</pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Uses the default cache of the "server" cache container.</p>
</li>
<li>
<p>Remember to close the registry!</p>
</li>
</ol>
</div>
</div>
</div>
</div>
      </div>
    </main><footer class="site-footer h-card">
  <data class="u-url" href="/wildflysite/"></data>

  <div class="wrapper">

    <h2 class="footer-heading">Wildfly</h2>

    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <li class="p-name">Wildfly</li></ul>
      </div>

      <div class="footer-col footer-col-2"><ul class="social-media-list"><li><a href="https://github.com/wildfly"><svg class="svg-icon"><use xlink:href="/wildflysite/assets/minima-social-icons.svg#github"></use></svg> <span class="username">wildfly</span></a></li><li><a href="https://www.twitter.com/WildFlyAS"><svg class="svg-icon"><use xlink:href="/wildflysite/assets/minima-social-icons.svg#twitter"></use></svg> <span class="username">WildFlyAS</span></a></li></ul>
</div>

      <div class="footer-col footer-col-3">
        <p></p>
      </div>
    </div>

  </div>

</footer>
</body>

</html>
